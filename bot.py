from fileinput import filename
import telebot
import os
import subprocess
import time
import datetime
import time
import imghdr
import os,sys,re
import subprocess
import requests
import datetime
import datetime
import sqlite3
import psutil
import hashlib
import random
import json
import logging
import sys
import imghdr
from bs4 import BeautifulSoup
import time
from telebot.types import InlineKeyboardMarkup, InlineKeyboardButton
from urllib.parse import urlparse
import threading
from io import BytesIO
import requests
import socket
from time import strftime
from telebot import types
from gtts import gTTS
import tempfile
from telegram.ext import CallbackContext
from telegram import Update, ChatMember
import qrcode
import sqlite3
from telebot import TeleBot
from datetime import date
from datetime import datetime
from datetime import datetime as dt
from concurrent.futures import ThreadPoolExecutor
from flask import Flask, jsonify
from datetime import datetime, date
import re
import subprocess
import json
import subprocess
# Configuration Variables
admins = ["ngotk999"]  # Admin username without '@'
name_bot = "ùôéùôãùòºùôà ùôéùôàùôé ùòæùòºùôáùôá"       # Bot name
zalo = "concac"        # Contact info
web = "hentai.com"  # Website link
boxtele = "Spamsmstracuuttvip"      # Telegram group link
API_URL = "https://api.sumiproject.net/ngl?username={username}&message={message}&amount={amount}"
GPT_API_URL = "https://api.sumiproject.net/gpt4?q={query}"
# Allowed group IDs
allowed_group_ids = [ -1002403107765]  # Must have '-' before chat ID
openai_api_key = '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'
# Bot Token
bot = telebot.TeleBot("7953417537:AAFCyNO6Nj_0VeyE3virc5et7mOdM_bCZj4")  # Token bot
API_TOKEN = 'c·∫∑c'  # Thay th·∫ø b·∫±ng token th·∫≠t c·ªßa b·∫°n cho d·ªãch v·ª• API
# Initialization Message
print("ngotk999 ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông th√†nh c√¥ng")
ALLOWED_GROUP_CHAT_ID = -1002403107765
# Admin Usernames and IDs
admin_us = ["ngotk999"]  # List of admin usernames
ADMIN_ID = '6043728545'  # List of admin IDs
app = Flask(__name__)
log_entries = []
# Variables for Bot Functionality
lan = {}
notifi = {}
auto_spam_active = False
last_sms_time = {}
allowed_users = []
processes = []
last_command_time = {}
user_state = {}
conversation_history = {}
sent_messages = []
active_vip_spam_processes = []
# Database Connection
# Dictionary to track user message timestamps
user_messages = {}
vip_folder_path = "./vip"

# Danh s√°ch l∆∞u tr·∫°ng th√°i ng∆∞·ªùi d√πng ƒë√£ s·ª≠ d·ª•ng /getkey
used_getkey_users = set()  
last_spam_time = {
    "+1234567890": {"last_spam_time": 1627424550, "initiator_name": "John Doe"},
    "+0987654321": {"last_spam_time": 1627426650, "initiator_name": "Jane Smith"}
}

SPAM_MESSAGE = " IB @ngotk999 ƒë·ªÉ v√†o box !"
SPAM_INTERVAL = 5  # Interval between each spam message in seconds
SPAM_LIMIT = 10  # Limit to prevent indefinite spamming
ALLOWED_GROUP_CHAT_ID = -1002403107765  # Replace with your group's chat ID

# Variables to control spamming and store spammed numbers
is_spamming = False
spam_thread = None
last_spam_time = {}  # Dictionary to store phone numbers with the last spam time
# Mute duration in seconds (4 minutes)
MUTE_DURATION = 240

# Maximum messages allowed within the spam detection window (30 seconds)
MAX_MESSAGES = 15
connection = sqlite3.connect('user_data.db')
cursor = connection.cursor()
users_keys = {}

# API Configuration
BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent'

def check_command_cooldown(user_id, command, cooldown):
    current_time = time.time()
    
    if user_id in last_command_time and current_time - last_command_time[user_id].get(command, 0) < cooldown:
        remaining_time = int(cooldown - (current_time - last_command_time[user_id].get(command, 0)))
        return remaining_time
    else:
        last_command_time.setdefault(user_id, {})[command] = current_time
        return None


# Create the users table if it doesn't exist
cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        expiration_time TEXT
    )
''')
connection.commit()

def TimeStamp():
    now = str(datetime.date.today())
    return now


def load_users_from_database():
  cursor.execute('SELECT user_id, expiration_time FROM users')
  rows = cursor.fetchall()
  for row in rows:
    user_id = row[0]
    expiration_time = datetime.strptime(row[1], '%Y-%m-%d %H:%M:%S')
    if expiration_time > datetime.now():
      allowed_users.append(user_id)


def save_user_to_database(connection, user_id, expiration_time):
  cursor = connection.cursor()
  cursor.execute(
    '''
        INSERT OR REPLACE INTO users (user_id, expiration_time)
        VALUES (?, ?)
    ''', (user_id, expiration_time.strftime('%Y-%m-%d %H:%M:%S')))
  connection.commit()

# Ki·ªÉm tra v√† t·∫°o th∆∞ m·ª•c vip
if not os.path.exists("./vip"):
    os.makedirs("./vip")

GPT_API_URL = 'https://api.openai.com/v1/completions'
headers = {
    'Authorization': f'Bearer {openai_api_key}',  # API Key c·ªßa OpenAI
    'Content-Type': 'application/json'
}





@bot.message_handler(commands=['add'])
def them(message):
    user_id = message.from_user.id
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    parts = message.text.split()
    if len(parts) != 4:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß th√¥ng tin: /them <ID> <Ng√†y H·∫øt H·∫°n> <S·ªë Ng√†y>')
        return
    
    idvip = parts[1]
    expiration_date = parts[2]  # ƒê·ªãnh d·∫°ng: DD-MM-YYYY
    expiration_days = parts[3]

    try:
        expiration_date_obj = datetime.strptime(expiration_date, '%d-%m-%Y').date()
    except ValueError:
        bot.reply_to(message, 'Ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng s·ª≠ d·ª•ng ƒë·ªãnh d·∫°ng DD-MM-YYYY.')
        return
    
    # L∆∞u v√†o file
    with open(f"./vip/{idvip}.txt", "w") as fii:
        fii.write(f"{expiration_date}|{expiration_days}")
    
    bot.reply_to(message, f'üí• Th√™m th√†nh c√¥ng {idvip} l√†m VIP v·ªõi ng√†y h·∫øt h·∫°n {expiration_date} üí•')





cooldown_dict = {}

@bot.message_handler(commands=['checkspamvip'])
def allspamvip(message):
    vip_dir = "./vip"
    vip_users = []
    
    # Check if the VIP directory exists
    if not os.path.exists(vip_dir):
        bot.reply_to(message, "Kh√¥ng c√≥ VIP n√†o ƒë∆∞·ª£c ƒëƒÉng k√Ω.")
        return
    
    # Loop through each VIP file
    for vip_file in os.listdir(vip_dir):
        user_id = os.path.splitext(vip_file)[0]
        vip_file_path = os.path.join(vip_dir, vip_file)
        
        try:
            with open(vip_file_path) as fo:
                data = fo.read().strip().split("|")
            
            expiration_date_str = data[0]
            expiration_date_obj = datetime.strptime(expiration_date_str, '%d-%m-%Y').date()
            remaining_days = (expiration_date_obj - date.today()).days
            
            # Check if VIP is active
            if remaining_days >= 0:
                vip_users.append(f"User ID: {user_id}\n+ Ng√†y h·∫øt h·∫°n: {expiration_date_str}\n+ S·ªë ng√†y c√≤n l·∫°i: {remaining_days} ng√†y\n")
            else:
                os.remove(vip_file_path)  # Remove expired VIP file
        except (ValueError, IndexError, FileNotFoundError):
            bot.reply_to(message, f"Th√¥ng tin VIP c·ªßa {user_id} kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.")
            continue

    # Compile and send VIP list
    if vip_users:
        vip_list = "\n\n".join(vip_users)
        bot.reply_to(message, f"‚ú® Danh s√°ch VIP hi·ªán t·∫°i ‚ú®\n\n{vip_list}")
    else:
        bot.reply_to(message, "Kh√¥ng c√≥ VIP n√†o ƒë∆∞·ª£c ƒëƒÉng k√Ω ho·∫∑c t·∫•t c·∫£ ƒë√£ h·∫øt h·∫°n.")
last_spam_time = {}
@bot.message_handler(commands=['spamvip'])
def spamvip(message):
    # Check if the message is in the allowed group chat
    

    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name or ""
    last_name = message.from_user.last_name or ""
    full_name = f"{first_name} {last_name}".strip()

    # Check if the user is registered as VIP
    vip_file_path = f"./vip/{user_id}.txt"
    if not os.path.exists(vip_file_path):
        bot.reply_to(message, 'B·∫°n ch∆∞a ƒëƒÉng k√Ω VIP. Vui l√≤ng li√™n h·ªá admin.')
        return

    try:
        # Read VIP info (expiration date and days)
        with open(vip_file_path) as fo:
            data = fo.read().split("|")
        
        expiration_date_str = data[0]  # Expiration date in DD-MM-YYYY
        expiration_days = int(data[1])  # Number of days
        expiration_date_obj = datetime.strptime(expiration_date_str, '%d-%m-%Y').date()
    except (ValueError, IndexError):
        bot.reply_to(message, 'Th√¥ng tin VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return

    # Check if VIP access has expired
    today = date.today()
    if today > expiration_date_obj:
        bot.reply_to(message, 'Key VIP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin.')
        os.remove(vip_file_path)  # Remove expired VIP file
        return

    # Ensure phone number argument is provided
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i.')
        return

    phone_number = message.text.split()[1]
    
    # Validate phone number format
    if not re.search("^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$", phone_number):
        bot.reply_to(message, 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá!')
        return

    # Paths to external scripts
    script_files = ["text1.py", "text2.py", "text3.py", "text4.py", "text5.py", "text6.py", "text7.py", "text8.py", "text9.py", "text10.py"]
    
    # Cooldown mechanism (120 seconds per user)
    current_time = time.time()
    if phone_number in last_spam_time:
        time_since_last_spam = current_time - last_spam_time[phone_number]
        if time_since_last_spam < 600:
            remaining_time = int(600 - time_since_last_spam)
            bot.reply_to(message, f'S·ªë ƒëi·ªán tho·∫°i {phone_number} ƒë√£ ƒë∆∞·ª£c spam. Vui l√≤ng ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i.')
            return
    last_spam_time[phone_number] = current_time
    # Update cooldown dictionary with 120-second wait
    cooldown_dict[username] = {'vip': current_time}

    # Execute external scripts concurrently and count them
    processes = []
    count = 0
    for script_file in script_files:
        script_path = os.path.join(os.getcwd(), script_file)
        process = subprocess.Popen(["python", script_path, phone_number, "50"])
        processes.append(process)
        count += 1

    # Print statement to log information
    print(f"user vip User ID: {user_id}, Name: {full_name}, Phone: {phone_number}, Count: 50 ")



    # Send confirmation to user with full name and phone number
    
    
    xinchao = f"""<blockquote> c√°i ƒë·ªãt m·∫π m√†y th·∫±ng {full_name}
    Attack Sent by : @{username}
    G·ª≠i y√™u c·∫ßu t·∫•n c√¥ng th√†nh c√¥ng üöÄ
     S·ªë t·∫•n c√¥ng üì±: [ {phone_number} ]
     S·ªë l∆∞·ª£t T·∫•n c√¥ng üì±: [ 33 L·∫ßn ]
     Plan C·ªßa B·∫°n : [ VIP ] 
     T√™n ng∆∞·ªùi d√πng üë§: [ {full_name} ]
     </blockquote>
     """
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
      types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),        
    )

    video_url = "https://files.catbox.moe/xbgx14.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='HTML', reply_markup=keyboard)

    # G·ª≠i tin nh·∫Øn "loading"
    sent_message = bot.reply_to(message, "ƒêang x·ª≠ l√Ω...")

    # Chu·ªói hi·ªáu ·ª©ng "Loading"
    
    loading_frames = [
        "Buy G√å C·ª© Ib @ngotk999 dcu ",
        "c√°i ƒë·ªãt m·∫π m√†y  ...",        
    ]
    

    # Hi·ªáu ·ª©ng "Loading"
    for _ in range(1):  # L·∫∑p 3 l·∫ßn hi·ªáu ·ª©ng
        for frame in loading_frames:
            bot.edit_message_text(frame, chat_id=message.chat.id, message_id=sent_message.message_id)
            time.sleep(0.2)

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i spam
    bot.edit_message_text(f"\n\n[ {full_name} ] B·∫Øt ƒê·∫ßu Spam  {phone_number}  ", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(1)  # Ch·ªù tr∆∞·ªõc khi x√≥a

    # X√≥a tin nh·∫Øn c≈©
    bot.delete_message(message.chat.id, message.message_id)  # X√≥a tin nh·∫Øn l·ªánh g·ªëc
    bot.delete_message(message.chat.id, sent_message.message_id)  # X√≥a tin nh·∫Øn "loading"



@bot.message_handler(commands=['smsvip'])
def smsvip(message):
    # Check if the message is in the allowed group chat
    

    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name or ""
    last_name = message.from_user.last_name or ""
    full_name = f"{first_name} {last_name}".strip()

    # Check if the user is registered as VIP
    vip_file_path = f"./vip/{user_id}.txt"
    if not os.path.exists(vip_file_path):
        bot.reply_to(message, 'B·∫°n ch∆∞a ƒëƒÉng k√Ω VIP. Vui l√≤ng li√™n h·ªá admin @ngotk999.')
        return

    try:
        # Read VIP info (expiration date and days)
        with open(vip_file_path) as fo:
            data = fo.read().split("|")
        
        expiration_date_str = data[0]  # Expiration date in DD-MM-YYYY
        expiration_days = int(data[1])  # Number of days
        expiration_date_obj = datetime.strptime(expiration_date_str, '%d-%m-%Y').date()
    except (ValueError, IndexError):
        bot.reply_to(message, 'Th√¥ng tin VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return

    # Check if VIP access has expired
    today = date.today()
    if today > expiration_date_obj:
        bot.reply_to(message, 'Key VIP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin.')
        os.remove(vip_file_path)  # Remove expired VIP file
        return

    # Ensure phone number argument is provided
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i.')
        return

    phone = message.text.split()[1]
    
    # Validate phone number format
    if not re.search("^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$", phone):
        bot.reply_to(message, 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá!')
        return

    # Paths to external scripts
    script_files = ["text1.py"]
    
    # Cooldown mechanism (120 seconds per user)
    current_time = time.time()
    if phone in last_spam_time:
        time_since_last_spam = current_time - last_spam_time[phone]
        if time_since_last_spam < 600:
            remaining_time = int(600 - time_since_last_spam)
            bot.reply_to(message, f'S·ªë ƒëi·ªán tho·∫°i {phone} ƒë√£ ƒë∆∞·ª£c spam. Vui l√≤ng ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i.')
            return
    last_spam_time[phone] = current_time
    # Update cooldown dictionary with 120-second wait
    cooldown_dict[username] = {'vip': current_time}

    # Execute external scripts concurrently and count them
    processes = []
    spam_count = 0
    for script_file in script_files:
        script_path = os.path.join(os.getcwd(), script_file)
        process = subprocess.Popen(["python", script_path, phone, "5"])
        processes.append(process)
        spam_count += 1

    # Print statement to log information
    print(f"user smsvip User ID: {user_id}, Name: {full_name}, Phone: {phone}, spam_count: 500 ")



    # Send confirmation to user with full name and phone number
    
    
    xinchao = f"""<blockquote> c√°i ƒë·ªãt m·∫π m√†y th·∫±ng {full_name}
    Attack Sent by : @{username}
    G·ª≠i y√™u c·∫ßu t·∫•n c√¥ng th√†nh c√¥ng üöÄ
    S·ªë t·∫•n c√¥ng üì±: [ {phone} ]
    S·ªë l·∫ßn spamüì±: [  100 ]
    Plan C·ªßa B·∫°n : [ VIP ] 
    T√™n ng∆∞·ªùi d√πng üë§: [ {full_name} ]
     </blockquote>
     """
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
      types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),        
    )

    video_url = "https://files.catbox.moe/xbgx14.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='HTML', reply_markup=keyboard)

    # G·ª≠i tin nh·∫Øn "loading"
    sent_message = bot.reply_to(message, "ƒêang x·ª≠ l√Ω...")

    # Chu·ªói hi·ªáu ·ª©ng "Loading"
    
    loading_frames = [
        "Buy G√å C·ª© Ib @ngotk999 dcu ",
        "c√°i ƒë·ªãt m·∫π m√†y  ...",        
    ]
    

    # Hi·ªáu ·ª©ng "Loading"
    for _ in range(1):  # L·∫∑p 3 l·∫ßn hi·ªáu ·ª©ng
        for frame in loading_frames:
            bot.edit_message_text(frame, chat_id=message.chat.id, message_id=sent_message.message_id)
            time.sleep(0.2)

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i spam
    bot.edit_message_text(f"\n\n[ {full_name} ] B·∫Øt ƒê·∫ßu Spam  {phone}  ", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(1)  # Ch·ªù tr∆∞·ªõc khi x√≥a

    # X√≥a tin nh·∫Øn c≈©
    bot.delete_message(message.chat.id, message.message_id)  # X√≥a tin nh·∫Øn l·ªánh g·ªëc
    bot.delete_message(message.chat.id, sent_message.message_id)  # X√≥a tin nh·∫Øn "loading"





def save_card_info(serial, pin, amount, carrier, full_name, username):
    with open('napthe.txt', 'a', encoding='utf-8') as file:  # M·ªü t·ªáp v·ªõi encoding='utf-8'
        file.write(f"Seri: {serial}, M√£ th·∫ª: {pin}, M·ªánh gi√°: {amount}, Nh√† m·∫°ng: {carrier}, Ng∆∞·ªùi d√πng: {full_name} (@{username})\n")

# H√†m g·ª≠i th√¥ng b√°o ƒë·∫øn admin v·ªÅ giao d·ªãch n·∫°p th·∫ª
def notify_admin_about_card(serial, pin, amount, carrier, full_name, username):
    notification = f"""
    üè∑Ô∏è Th√¥ng b√°o N·∫°p Th·∫ª:

    üí≥ Seri: {serial}
    üîë M√£ th·∫ª: {pin}
    üíµ M·ªánh gi√°: {amount} VND
    üì± Nh√† m·∫°ng: {carrier}
    üìù Ng∆∞·ªùi d√πng: {full_name} (@{username})
    """
    try:
        bot.send_message(ADMIN_ID, notification)
        print("Th√¥ng b√°o ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn admin.")
    except Exception as e:
        print(f"L·ªói khi g·ª≠i th√¥ng b√°o ƒë·∫øn admin: {e}")

# L·ªánh y√™u c·∫ßu th√¥ng tin th·∫ª t·ª´ ng∆∞·ªùi d√πng
@bot.message_handler(commands=['napthe'])
def request_card_info(message):
    # Y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p seri th·∫ª
    msg = bot.reply_to(message, "Vui l√≤ng nh·∫≠p Seri th·∫ª:")
    bot.register_next_step_handler(msg, process_card_serial)

# X·ª≠ l√Ω th√¥ng tin th·∫ª sau khi ng∆∞·ªùi d√πng nh·∫≠p Seri
def process_card_serial(message):
    serial = message.text.strip()

    # Y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p m√£ th·∫ª
    msg = bot.reply_to(message, "Vui l√≤ng nh·∫≠p m√£ th·∫ª:")
    bot.register_next_step_handler(msg, process_card_pin, serial)

# X·ª≠ l√Ω m√£ th·∫ª
def process_card_pin(message, serial):
    pin = message.text.strip()

    # Y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p m·ªánh gi√° th·∫ª
    msg = bot.reply_to(message, "Vui l√≤ng nh·∫≠p m·ªánh gi√° th·∫ª (VND):")
    bot.register_next_step_handler(msg, process_card_amount, serial, pin)

# X·ª≠ l√Ω m·ªánh gi√° th·∫ª
def process_card_amount(message, serial, pin):
    amount = message.text.strip()

    # Y√™u c·∫ßu ng∆∞·ªùi d√πng nh·∫≠p nh√† m·∫°ng
    msg = bot.reply_to(message, "Vui l√≤ng nh·∫≠p nh√† m·∫°ng (Viettel, Mobifone, Vinaphone, vv):")
    bot.register_next_step_handler(msg, process_card_carrier, serial, pin, amount)

# X·ª≠ l√Ω nh√† m·∫°ng
def process_card_carrier(message, serial, pin, amount):
    carrier = message.text.strip()

    # L∆∞u th√¥ng tin th·∫ª v√†o file
    save_card_info(serial, pin, amount, carrier, message.from_user.full_name, message.from_user.username)

    # Th√¥ng b√°o cho ng∆∞·ªùi d√πng r·∫±ng giao d·ªãch ƒë√£ ƒë∆∞·ª£c ghi nh·∫≠n
    bot.reply_to(message, "Admin ƒêang Check M√£ Th·∫ª Vui L√≤ng Ch·ªù 1 - 2 PH√öT !")

    # G·ª≠i th√¥ng b√°o cho admin v·ªÅ giao d·ªãch n·∫°p th·∫ª
    notify_admin_about_card(serial, pin, amount, carrier, message.from_user.full_name, message.from_user.username)

# Ch·∫°y bot







@bot.message_handler(commands=['checkuserspam'])
def checkuserspam(message):
    # Ensure an argument (phone number or VIP username) is provided
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i ho·∫∑c t√™n ƒëƒÉng nh·∫≠p VIP ƒë·ªÉ ki·ªÉm tra.')
        return

    identifier = message.text.split()[1]

    # Check if identifier is a phone number or a username
    if identifier.isdigit():
        # Treat identifier as a phone number
        phone_number = identifier
        if phone_number in last_spam_time:
            # Calculate time since last spam for the phone number
            last_time = last_spam_time[phone_number]
            time_since_last_spam = time.time() - last_time
            remaining_cooldown = max(0, int(220 - time_since_last_spam))

            if remaining_cooldown > 0:
                bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {phone_number} ƒë√£ ƒë∆∞·ª£c spam g·∫ßn ƒë√¢y. Vui l√≤ng ƒë·ª£i {remaining_cooldown} gi√¢y tr∆∞·ªõc khi spam l·∫°i.")
            else:
                bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {phone_number} c√≥ th·ªÉ ƒë∆∞·ª£c spam l·∫°i.")
        else:
            bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {phone_number} ch∆∞a b·ªã spam g·∫ßn ƒë√¢y v√† c√≥ th·ªÉ ƒë∆∞·ª£c spam.")

    else:
        # Treat identifier as a VIP username
        username = identifier
        if username in cooldown_dict and 'vip' in cooldown_dict[username]:
            last_time = cooldown_dict[username]['vip']
            time_since_last_spam = time.time() - last_time
            remaining_cooldown = max(0, int(220 - time_since_last_spam))

            if remaining_cooldown > 0:
                bot.reply_to(message, f"Ng∆∞·ªùi d√πng VIP @{username} ƒë√£ s·ª≠ d·ª•ng l·ªánh spamvip g·∫ßn ƒë√¢y. Vui l√≤ng ƒë·ª£i {remaining_cooldown} gi√¢y tr∆∞·ªõc khi d√πng l·∫°i.")
            else:
                bot.reply_to(message, f"Ng∆∞·ªùi d√πng VIP @{username} c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh spamvip.")
        else:
            bot.reply_to(message, f"Ng∆∞·ªùi d√πng VIP @{username} ch∆∞a s·ª≠ d·ª•ng l·ªánh spamvip g·∫ßn ƒë√¢y v√† c√≥ th·ªÉ s·ª≠ d·ª•ng.")

@bot.message_handler(commands=['test'])
def test(message):
    # Check if the message is in the allowed group chat
    

    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name or ""
    last_name = message.from_user.last_name or ""
    full_name = f"{first_name} {last_name}".strip()

    # Check if the user is registered as VIP
    vip_file_path = f"./vip/{user_id}.txt"
    if not os.path.exists(vip_file_path):
        bot.reply_to(message, 'B·∫°n ch∆∞a ƒëƒÉng k√Ω VIP. Vui l√≤ng li√™n h·ªá admin.')
        return

    try:
        # Read VIP info (expiration date and days)
        with open(vip_file_path) as fo:
            data = fo.read().split("|")
        
        expiration_date_str = data[0]  # Expiration date in DD-MM-YYYY
        expiration_days = int(data[1])  # Number of days
        expiration_date_obj = datetime.strptime(expiration_date_str, '%d-%m-%Y').date()
    except (ValueError, IndexError):
        bot.reply_to(message, 'Th√¥ng tin VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return

    # Check if VIP access has expired
    today = date.today()
    if today > expiration_date_obj:
        bot.reply_to(message, 'Key VIP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin.')
        os.remove(vip_file_path)  # Remove expired VIP file
        return

    # Ensure phone number argument is provided
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i.')
        return

    phone_number = message.text.split()[1]
    
    # Validate phone number format
    if not re.search("^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$", phone_number):
        bot.reply_to(message, 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá!')
        return

    # Paths to external scripts
    script_files = ["text1.py", "text2.py", "text3.py", "text4.py", "text5.py", "text6.py", "text7.py", "text8.py", "text9.py", "text10.py"]
    
    # Cooldown mechanism (120 seconds per user)
    current_time = time.time()
    if phone_number in last_spam_time:
        time_since_last_spam = current_time - last_spam_time[phone_number]
        if time_since_last_spam < 120:
            remaining_time = int(120 - time_since_last_spam)
            bot.reply_to(message, f'S·ªë ƒëi·ªán tho·∫°i {phone_number} ƒë√£ ƒë∆∞·ª£c spam. Vui l√≤ng ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i.')
            return
    last_spam_time[phone_number] = current_time
    # Update cooldown dictionary with 120-second wait
    cooldown_dict[username] = {'vip': current_time}

    # Execute external scripts concurrently and count them
    processes = []
    count = 0
    for script_file in script_files:
        script_path = os.path.join(os.getcwd(), script_file)
        process = subprocess.Popen(["python", script_path, phone_number, "5"])
        processes.append(process)
        count += 1

    # Print statement to log information
    print(f"/test User ID: {user_id}, Name: {full_name}, Phone: {phone_number}, Count: 5 ")



    # Send confirmation to user with full name and phone number
    
    
    response = (
    f" Attack sent  \n"
    f"üöÄ G·ª≠i y√™u c·∫ßu t·∫•n c√¥ng th√†nh c√¥ng üöÄ\n"
    f"+ S·ªë t·∫•n c√¥ng üì±: [ {phone_number} ]\n"
    f"+ S·ªë l∆∞·ª£t T·∫•n c√¥ng üì±: [ 5 L·∫ßn ]\n"
    f"+ T√™n ng∆∞·ªùi d√πng üë§: {full_name} (@{username})"
)
    sent_message = bot.reply_to(message, response)   
# Send the reply
    bot.reply_to(message,response)
    # Short delay to ensure the bot has sent the reply
    # Wait for a moment before the next part of the "shattering" effect
    
    bot.edit_message_text(f"\n\n 3 ", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    # Another effect stage (disintegration)
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading .", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(1)
    
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading .", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading .", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(0.2)

    bot.edit_message_text(f"\n\n[ {full_name} ] B·∫Øt ƒê·∫ßu Spam  {phone_number}  ", chat_id=message.chat.id, message_id=sent_message.message_id)
    # Another effect stage (disintegration)
    time.sleep(1)
    bot.delete_message(message.chat.id, message.message_id)  # Delete the original message
    bot.delete_message(sent_message.chat.id, sent_message.message_id)


@bot.message_handler(commands=['attack'])
def test(message):
    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name or ""
    last_name = message.from_user.last_name or ""
    full_name = f"{first_name} {last_name}".strip()

    # Check VIP status
    vip_file_path = f"./vip/{user_id}.txt"
    if not os.path.exists(vip_file_path):
        bot.reply_to(message, 'B·∫°n ch∆∞a ƒëƒÉng k√Ω VIP. Vui l√≤ng li√™n h·ªá admin.')
        return

    try:
        # Read VIP information
        with open(vip_file_path) as fo:
            data = fo.read().split("|")
        
        expiration_date_str = data[0]  # Expiration date in DD-MM-YYYY
        expiration_date_obj = datetime.strptime(expiration_date_str, '%d-%m-%Y').date()
    except (ValueError, IndexError):
        bot.reply_to(message, 'Th√¥ng tin VIP kh√¥ng h·ª£p l·ªá. Vui l√≤ng li√™n h·ªá admin.')
        return

    # Check if VIP access has expired
    today = date.today()
    if today > expiration_date_obj:
        bot.reply_to(message, 'Key VIP ƒë√£ h·∫øt h·∫°n. Vui l√≤ng li√™n h·ªá admin.')
        os.remove(vip_file_path)  # Remove expired VIP file
        return

    # Ensure necessary arguments are provided
    args = message.text.split()
    if len(args) < 5:  # Expecting: /attack host time port methods
        bot.reply_to(
            message, 
            "Vui l√≤ng nh·∫≠p ƒë·ªß th√¥ng tin: /attack <host> <time> <port> <method>\n"
            "method = [layer7 .tls-kill .browser | layer4 .ovh-killer]"
        )
        return

    host = args[1]
    time = args[2]
    port = args[3]
    methods = args[4]

    try:
        # API request
        api_url = f"http://api.ventox.id.vn/api/attack"
        params = {
            "username": "ventox",
            "key": "ventox",
            "host": host,
            "time": time,
            "port": port,
            "method": methods
        }
        response = requests.get(api_url, params=params)

        # Handle API response
        if response.status_code == 200:
            message_text = (
                f"üöÄ **Attack Sent!** üöÄ\n"
                f"Host: [ {host} ]\n"
                f"Port: [ {port} ]\n"
                f"Time: [ {time} ]\n"
                f"Method: [ {methods} ]\n"
                f"Requested by: {full_name} (@{username})"
            )
        else:
            message_text = f"L·ªói API: {response.status_code} - {response.text}"

    except Exception as e:
        message_text = f"Kh√¥ng th·ªÉ g·ª≠i y√™u c·∫ßu API: {str(e)}"

    # Send the result to the user
    bot.reply_to(message, message_text, parse_mode="Markdown")





@bot.message_handler(commands=['stopspamvip'])
def stopspamvip(message):
    user_id = message.from_user.id

    # Ki·ªÉm tra quy·ªÅn truy c·∫≠p c·ªßa ng∆∞·ªùi d√πng
    if user_id != ADMIN_ID:  # Ensure we're using ADMIN_ID correctly
        vip_file_path = f"./vip/{user_id}.txt"
        if not os.path.exists(vip_file_path):
            bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn d·ª´ng spam VIP.")
            return
    
    if len(message.text.split()) < 2:
        bot.reply_to(message, "‚ö†Ô∏è Vui l√≤ng cung c·∫•p s·ªë ƒëi·ªán tho·∫°i ƒë·ªÉ d·ª´ng spam VIP.")
        return

    phone_number = message.text.split()[1]

    # Ki·ªÉm tra xem c√≥ ti·∫øn tr√¨nh spam n√†o cho s·ªë ƒëi·ªán tho·∫°i n√†y kh√¥ng
    if phone_number in active_vip_spam_processes:
        if user_id == ADMIN_ID or user_id == message.from_user.id:
            # Attempt to stop all processes associated with the phone number
            try:
                for process in active_vip_spam_processes[phone_number]:
                    process.terminate()  # D·ª´ng ti·∫øn tr√¨nh
                    process.wait()  # ƒê·∫£m b·∫£o ti·∫øn tr√¨nh ƒë√£ k·∫øt th√∫c
                    bot.reply_to(message, f"‚úÖ ƒê√£ d·ª´ng spam VIP cho s·ªë ƒëi·ªán tho·∫°i {phone_number}.")
                
                # X√≥a s·ªë ƒëi·ªán tho·∫°i kh·ªèi danh s√°ch sau khi d·ª´ng spam
                del active_vip_spam_processes[phone_number]
            except Exception as e:
                bot.reply_to(message, f"‚ùå L·ªói khi d·ª´ng spam: {str(e)}")
        else:
            bot.reply_to(message, "‚ùå B·∫°n kh√¥ng c√≥ quy·ªÅn d·ª´ng spam n√†y.")
    else:
        bot.reply_to(message, f"‚ùå Kh√¥ng t√¨m th·∫•y ti·∫øn tr√¨nh spam VIP n√†o cho s·ªë ƒëi·ªán tho·∫°i {phone_number}.")


@bot.message_handler(commands=['listspammed'])
def list_spammed(message):
    if not last_spam_time:
        bot.reply_to(message, "There are currently no spammed numbers.")
        return

    response = "Recently spammed numbers:\n\n"
    current_time = time.time()

    for phone_number, last_time in last_spam_time.items():
        time_since_last_spam = int(current_time - last_time)
        remaining_cooldown = max(0, SPAM_INTERVAL - time_since_last_spam)  # Adjust cooldown if needed

        response += (
            f" _______________________________\n"
            f"  + S·ªë ƒëi·ªán tho·∫°i : {phone_number}\n"
            f"  + Time spam : {time_since_last_spam} Gi√¢y Tr∆∞·ªõc\n"
            f"  + Time c√≤n l·∫°i : {remaining_cooldown} Gi√¢y \n"
            f" _______________________________\n\n"
        )

    bot.reply_to(message, response)



@bot.message_handler(commands=['huyvip'])
def remove_vip(message):
    admin_id = message.from_user.id
    if str(admin_id) != ADMIN_ID:  # So s√°nh v·ªõi ADMIN_ID d∆∞·ªõi d·∫°ng chu·ªói
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Xin cung c·∫•p ID ng∆∞·ªùi d√πng ƒë·ªÉ hu·ª∑ quy·ªÅn VIP.')
        return

    user_id = int(message.text.split()[1])
    # X√≥a VIP trong file
    vip_file_path = f"./vip/{user_id}.txt"
    if os.path.exists(vip_file_path):
        os.remove(vip_file_path)
        bot.reply_to(message, f'Ng∆∞·ªùi d√πng {user_id} ƒë√£ b·ªã hu·ª∑ quy·ªÅn VIP th√†nh c√¥ng.')
    else:
        bot.reply_to(message, f'Ng∆∞·ªùi d√πng {user_id} kh√¥ng ph·∫£i l√† VIP.')

start_time = time.time()  # Ghi l·∫°i th·ªùi gian b·∫Øt ƒë·∫ßu

def get_elapsed_time():
    elapsed_time = time.time() - start_time  # T√≠nh th·ªùi gian ƒë√£ tr√¥i qua
    return elapsed_time

load_users_from_database()
def is_key_approved(chat_id, key):
    if chat_id in users_keys:
        user_key, timestamp = users_keys[chat_id]
        if user_key == key:
            current_time = datetime.datetime.now()
            if current_time - timestamp <= datetime.timedelta(hours=2):
                return True
            else:
                del users_keys[chat_id]
    return False
def escape_markdown(text):
    """Tho√°t c√°c k√Ω t·ª± ƒë·∫∑c bi·ªát ƒë·ªÉ s·ª≠ d·ª•ng trong ch·∫ø ƒë·ªô MarkdownV2"""
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    return ''.join(f'\\{char}' if char in escape_chars else char for char in text)
@bot.message_handler(commands=['start', 'help'])
def send_welcome(message):
    username = message.from_user.username
    xinchao = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ 18 c√¢u l·ªánh d√†nh cho ng∆∞·ªùi d√πng
‚≠ê L·ªánh kh·ªüi ƒë·∫ßu
¬ª /start: L·ªánh kh·ªüi ƒë·∫ßu 
¬ª /help: L·ªánh tr·ª£ gi√∫p 
‚öîÔ∏è L·ªánh Spam
¬ª /getkey: ƒê·ªÉ l·∫•y key ng√†y 
¬ª /key: ƒê·ªÉ nh·∫≠p key ng√†y
¬ª /spam: Spam 20 l·∫ßn  
¬ª /ngl: Spam ngl
¬ª /stop_spam: D·ª´ng spam sƒët </blockquote>"
<blockquote expandable>üî∞Khi ta·ªç key m·ªõi d√πng ƒë∆∞·ª£c
¬ª /enkey: khi c√≥ key ƒëc t·∫°o b·ªüi admin
¬ª /taokey: t·∫°o key ch·ªâ c√≥ admin  
¬ª /spams: spam c√≥ call </blockquote>
Ô∏è<blockquote expandable>üèÜ L·ªánh cho th√†nh vi√™n VIP: /vip </blockquote>"
<blockquote expandable>üî∞L·ªánh ti·ªán √≠ch
¬ª /napthe: N·∫°p th·∫ª T·ªõi Admin 
¬ª /bank: bank ti·ªÅn admin  
¬ª /admin: Th√¥ng tin admin 
¬ª /checkfb: Th√¥ng tin Fb
¬ª /voice: ƒê·ªÉ ƒë·ªïi vƒÉn b·∫£n th√†nh gi·ªçng n√≥i
¬ª /info: ƒê·ªÉ l·∫•y id ng∆∞·ªùi c·ªßa b·∫£n th√¢n  
¬ª /checkip: ƒê·ªÉ check th√¥ng tin ip 
¬ª /vi_pham: ƒê·ªÉ check vi ph·∫°m cho bi·ªÉn s·ªë 
¬ª /avtfb: getavtfb xuy√™n khi√™ng
¬ª /tiktok: ƒê·ªÉ l·∫•y th√¥ng tin video 
¬ª /qr: t·∫°o m√£ qr 
¬ª /adm: l·ªánh cho admin
¬ª /html: l·∫•y html web </blockquote>
"""

    # T·∫°o c√°c n√∫t n·∫±m ngang
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
      types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),
        types.InlineKeyboardButton("ü§ñ Bot", url="https://t.me/KLTOOLBOT")
    )

    video_url = "https://files.catbox.moe/xbgx14.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='HTML', reply_markup=keyboard)
# H√†m l·∫•y Facebook ID t·ª´ API
def get_facebook_id(link: str) -> str:
    api_url = f"https://api.sumiproject.net/facebook/uid?link={link}"
    response = requests.get(api_url)
    
    if response.status_code == 200:
        data = response.json()
        return data.get('id', 'Kh√¥ng t√¨m th·∫•y ID')
    else:
        return f"L·ªói API: {response.status_code}"
@bot.message_handler(commands=['vip'])
def send_welcome(message):
    username = message.from_user.username
    lenhvip = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ T·∫•t C·∫£ c√¢u l·ªánh d√†nh cho ADM
Ô∏èü•àL·ªánh Cho VIP
¬ª /spamvip: Call Spam API M√∫p
¬ª /smsvip :  Sms Spam API M√∫p
¬ª /checkuserspam : Check c·ªßa b·∫°n
¬ª /listspammed : danh s√°ch spam</blockquote>
<blockquote expandable>üìñ T·∫•t C·∫£ SMS Vip
Ô∏èü•àL·ªánh Cho Vip Basic
¬ª /smsvip: Call Spam API Lt</blockquote>
<blockquote expandable>üìñ T·∫•t C·∫£ Basic
Ô∏èü•àL·ªánh Cho Vip Basic
¬ª /spambasic: Call Spam API Lt</blockquote>
<blockquote expandable>ü•àL·ªánh Cho VIP Khi Vip Test Kh√°ch
¬ª /test : Spam Vip Test Kh√°ch
¬ª /attack : ddos web end ip layer 4
¬ª @ngotk999
</blockquote>"""
        
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
        types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),
        types.InlineKeyboardButton("ü§ñ Bot", url="https://t.me/KLTOOLBOT")
    )

    video_url = "https://files.catbox.moe/yaztwg.mp4"
    bot.send_video(message.chat.id, video_url, caption=lenhvip, parse_mode='HTML', reply_markup=keyboard)


@bot.message_handler(commands=['adm'])
def send_welcome(message):
    username = message.from_user.username
    lenhadmin = f"""<blockquote> üöÄüìñ‚≠êBOT SPAM CALL + SMS‚≠êüìñüöÄ </blockquote>
<b>[‚≠ê] Xin ch√†o @{username}</b> 
<blockquote expandable>üìñ T·∫•t C·∫£ c√¢u l·ªánh d√†nh cho ADM
üî∞L·ªánh Cho Admin
¬ª /cpu: ƒê·ªÉ xem c·∫•u h√¨nh
¬ª /restart: ƒê·ªÉ kh·ªüi ƒë·ªông l·∫°i bot
¬ª /all: ƒê·ªÉ th√¥ng b√°o cho c·∫£ nh√≥m
¬ª /huyvip: ƒê·ªÉ h·ªßy vip b·∫±ng id
¬ª /im: ƒê·ªÉ kh√≥a m√µm 
¬ª /unim: ƒê·ªÉ m·ªü kh√≥a m√µm
¬ª /add: ƒê·ªÉ th√™m ng∆∞·ªùi d√πng v√†o vip
¬ª /huyvip: ƒê·ªÉ h·ªßy vip
¬ª /lock: ƒê·ªÉ kh√≥a chat
¬ª /unlock: ƒê·ªÉ m·ªü chat
¬ª /ban: ƒê·ªÉ kick ng∆∞·ªùi d√πng</blockquote>"""
        
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
        types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),
        types.InlineKeyboardButton("ü§ñ Bot", url="https://t.me/KLTOOLBOT")
    )

    video_url = "https://files.catbox.moe/yaztwg.mp4"
    bot.send_video(message.chat.id, video_url, caption=lenhadmin, parse_mode='HTML', reply_markup=keyboard)

@bot.message_handler(commands=['napvip'])
def send_welcome(message):
    user_id = message.from_user.id
    with open('id', 'r') as file:
        if str(message.chat.id) not in file.read():
            with open('id', 'a') as file:
                file.write(str(message.chat.id) + '\n')
    username = escape_markdown(message.from_user.username)
    xinchao = f"""     ‚≠ì {escape_markdown(name_bot)} ‚≠ì
¬ª Xin ch√†o @{username}
¬ª /bank: Bank ti·ªÅn
"""
    video_url = "https://files.catbox.moe/yaztwg.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='MarkdownV2')
@bot.message_handler(commands=['bank'])
def handle_bank(message):
    markup = types.InlineKeyboardMarkup()
    btn_momo = types.InlineKeyboardButton(text='Momo', callback_data='momo')
    btn_mbbank = types.InlineKeyboardButton(text='mbbank', callback_data='mbbank')

    markup.add(btn_momo)
    bot.reply_to(message, "Vui L√≤ng Ch·ªçn Bank:", reply_markup=markup)

@bot.callback_query_handler(func=lambda call: call.data in ['momo'])
def handle_bank_selection(call):
    user_id = call.from_user.id
    if call.data == 'mbbank':
        qr_code_url = f""
        caption = f"""
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì BIDV ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ
> ‚îú Ng√¢n H√†ng: ùôàùòΩ ùòΩùòºùôâùôÜ
> ‚îú STK: 9704229201122741793
> ‚îú T√™n: ùôâùôúùô™ùôÆùôöùô£ ùô©ùôùùôû ùô£ùôúùô§ùôò ùôÆùôöùô£ 
> ‚îú ND: ùô£ùôñùô•ùô´ùôûùô•_{user_id}
> ‚îú S·ªë Ti·ªÅn: 20.000 ùôëùôâùòø
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

L∆∞u √ù:
    + Khi Bank Nh·ªõ Nh·∫≠p ƒê√∫ng N·ªôi Dung Chuy·ªÉn Ti·ªÅn.
    + Khi Bank Xong Vui L√≤ng Li√™n H·ªá @ngotk999 ƒê·ªÉ Add Vip.
"""
        # Escape the caption
        caption = escape_markdown(caption)

        bot.send_photo(call.message.chat.id, qr_code_url, caption=caption, parse_mode='MarkdownV2')
    elif call.data == 'momo':
        momo = f"""
> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì Mbbank ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ
> ‚îú Ng√¢n H√†ng: Momo
> ‚îú STK: 9704229201122741793
> ‚îú T√™n: ùôâùôúùô™ùôÆùôöùô£ ùô©ùôùùôû ùô£ùôúùô§ùôò ùôÆùôöùô£ 
> ‚îú ND: ùô£ùôñùô•ùô´ùôûùô•_{user_id}
> ‚îú S·ªë Ti·ªÅn: 20.000 VNƒê
> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

L∆∞u √ù:
    + Khi Bank Nh·ªõ Nh·∫≠p ƒê√∫ng N·ªôi Dung Chuy·ªÉn Ti·ªÅn.
    + Khi Bank Xong Vui L√≤ng Li√™n H·ªá @ngotk999 ƒê·ªÉ Add Vip.
"""
        # Escape the momo message
        momo = escape_markdown(momo)

        bot.reply_to(call.message, momo, parse_mode='MarkdownV2')
@bot.message_handler(commands=['admin'])
def send_admin_info(message):
    username = message.from_user.username
    admin_info = f'''
    ‚≠ì {escape_markdown(name_bot)} ‚≠ì
    ¬ª Xin ch√†o @{escape_markdown(username)}
    ¬ª Admin: [Click](@{admins})
    ¬ª Zalo: {escape_markdown(zalo)}
    ¬ª Website: {escape_markdown(web)}
    ¬ª Telegram: @{escape_markdown(admins)}
    ¬ª L∆∞u √ù: Spam Li√™n
       T·ª•c L·ªánh ƒÇn Ban
       ƒê·ª´ng K√™u M·ªü 
    '''
    video_url = "https://files.catbox.moe/5l74tr.mp4"
    bot.send_video(message.chat.id, video_url, caption=admin_info, parse_mode='MarkdownV2')

@bot.message_handler(commands=['cpu'])
def check_system_info(message):
    admin_id = message.from_user.id
    if str(admin_id) != ADMIN_ID:  # So s√°nh v·ªõi ADMIN_ID d∆∞·ªõi d·∫°ng chu·ªói
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    cpu_percent = psutil.cpu_percent()
    memory_percent = psutil.virtual_memory().percent

    message_text = f"üñ• Th√¥ng Tin Pc üñ•\n\n" \
                   f"üáªüá≥ Admin: T·∫•n ki·ªát Dzz üáªüá≥\n\n" \
                   f"üìä Cpu: {cpu_percent}%\n" \
                   f"üß† Memory: {memory_percent}%"
    bot.reply_to(message, message_text)

@bot.message_handler(commands=['restart'])
def restart(message):
    admin_id = message.from_user.id
    if str(admin_id) != ADMIN_ID:  # So s√°nh v·ªõi ADMIN_ID d∆∞·ªõi d·∫°ng chu·ªói
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    bot.reply_to(message, 'üöÄ Bot s·∫Ω ƒë∆∞·ª£c kh·ªüi ƒë·ªông l·∫°i trong gi√¢y l√°t... üöÄ')
    time.sleep(10)
    python = sys.executable
    os.execl(python, python, *sys.argv)


is_bot_active = True
import os
import subprocess
import time

cooldown_dict = {}
processes = []



@bot.message_handler(commands=['all'])
def notify_all_members(message):
    admin_id = message.from_user.id
    if str(admin_id) != ADMIN_ID:  # Check if the sender is the admin
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    try:
        # Get the list of administrators
        admins = bot.get_chat_administrators(message.chat.id)
        admin_ids = [admin.user.id for admin in admins]

        # Create the notification message for admins
        notification = "<b>üì¢ Th√¥ng b√°o t·ª´ admin:</b>\n"

        # Tagging all admins
        for admin in admins:
            notification += f"@{admin.user.username} " if admin.user.username else ""

        # Send notification to all admins
        bot.send_message(message.chat.id, notification, parse_mode='HTML')

        # Send a message to all group members (excluding the bot itself)
        members = bot.get_chat_members(message.chat.id)  # Get list of all members
        for member in members:
            if member.user.is_bot:  # Skip bots
                continue

            # Send a notification to each user
            bot.send_message(
                member.user.id,
                "üì¢ ƒê√¢y l√† th√¥ng b√°o t·ª´ admin!\n" + notification,
                parse_mode='HTML'
            )

    except Exception as e:
        bot.reply_to(message, '<blockquote>Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c quy·ªÅn h·∫°n c·ªßa bot.</blockquote>', parse_mode='HTML')

@bot.message_handler(commands=['gemini'])
def start_gemini_conversation(message):
    user_id = message.from_user.id

    # Ki·ªÉm tra quy·ªÅn s·ª≠ d·ª•ng l·ªánh
    if message.from_user.username not in admin_us:
        bot.reply_to(message, "B·∫°n Kh√¥ng C√≥ Quy·ªÅn S·ª≠ D·ª•ng L·ªánh N√†y")
        return

    # L·∫•y n·ªôi dung sau l·ªánh /gemini
    input_text = message.text[8:].strip()

    if not input_text:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p ƒë·∫ßu v√†o.")
        return
    # Kh·ªüi t·∫°o l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán cho ng∆∞·ªùi d√πng
    conversation_history[user_id] = [{"role": "user", "content": input_text}]
    # G·ªçi API v√† tr·∫£ l·ªùi ng∆∞·ªùi d√πng
    send_to_gemini_api(message, user_id, input_text)

# X·ª≠ l√Ω l·ªánh /getid
@bot.message_handler(commands=['getid'])
def send_facebook_id(message):
    waiting_message = bot.reply_to(message, 'üîç')
    try:
        # T√°ch link t·ª´ tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
        link = message.text.split()[1]
        facebook_id = get_facebook_id(link)
        bot.reply_to(message, f"<b>ID cho link </b>: <code>{facebook_id}</code>", parse_mode='html')
        bot.delete_message(message.chat.id, waiting_message.message_id)
    except IndexError:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p link Facebook h·ª£p l·ªá sau l·ªánh /getid.")
        bot.delete_message(message.chat.id, waiting_message.message_id)
@bot.message_handler(commands=['avtfb'])
def get_facebook_avatar(message):
    user_id = message.from_user.id

    # Check command format
    if len(message.text.split()) != 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p ƒë√∫ng ƒë·ªãnh d·∫°ng\nExample: /avtfb [link ho·∫∑c id]')
        return
    
    # G·ª≠i tin nh·∫Øn ch·ªù x·ª≠ l√Ω
    waiting_message = bot.reply_to(message, 'üîç')

    # Get parameter from the message
    parameter = message.text.split()[1]

    # Determine if it's a Facebook ID or a link
    if parameter.isdigit():  # If it's a Facebook ID
        facebook_id = parameter
    else:  # If it's a Facebook link
        if 'facebook.com' not in parameter:
            bot.edit_message_text('Li√™n k·∫øt kh√¥ng ph·∫£i t·ª´ Facebook', message.chat.id, waiting_message.message_id)
            return
        
        # Use the API to get the Facebook ID from the URL
        api_url = f"https://api.sumiproject.net/facebook/uid?link={parameter}"
        try:
            api_response = requests.get(api_url)
            api_response.raise_for_status()
            json_response = api_response.json()
            
            if 'id' in json_response:
                facebook_id = json_response['id']
            else:
                bot.edit_message_text('Kh√¥ng th·ªÉ l·∫•y ID t·ª´ li√™n k·∫øt Facebook. Vui l√≤ng th·ª≠ l·∫°i v·ªõi m·ªôt li√™n k·∫øt kh√°c.', message.chat.id, waiting_message.message_id)
                return
            
        except requests.RequestException as e:
            bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra khi truy c·∫≠p API: {e}', message.chat.id, waiting_message.message_id)
            return
        except Exception as e:
            bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra: {e}', message.chat.id, waiting_message.message_id)
            return

    # Use the provided Facebook URL for the profile picture
    graph_url = f"https://graph.facebook.com/{facebook_id}/picture?width=1500&height=1500&access_token=2712477385668128%7Cb429aeb53369951d411e1cae8e810640"
    
    try:
        response = requests.get(graph_url)
        response.raise_for_status()
        
        # Send the avatar image to the user with a caption
        caption = f"<b>Avatar cho Facebook ID ho·∫∑c link</b>: <code>{facebook_id}</code>"
        bot.send_photo(message.chat.id, response.url, caption=caption, parse_mode='html')
        
        # X√≥a tin nh·∫Øn ch·ªù sau khi ho√†n th√†nh
        bot.delete_message(message.chat.id, waiting_message.message_id)
    
    except requests.RequestException as e:
        bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra khi truy c·∫≠p Facebook: {e}', message.chat.id, waiting_message.message_id)
    except Exception as e:
        bot.edit_message_text(f'C√≥ l·ªói x·∫£y ra: {e}', message.chat.id, waiting_message.message_id)


def check_car_info(bsx):
    url = f'https://vietcheckcar.com/api/api.php?api_key=sfund&bsx={bsx}&bypass_cache=0&loaixe=1&vip=0'
    response = requests.get(url)
    return response.json()

@bot.message_handler(commands=['vi_pham'])
def handle_check(message):
    try:
        # L·∫•y bi·ªÉn s·ªë t·ª´ tin nh·∫Øn
        bsx = message.text.split()[1]
        # G·ªçi API v√† l·∫•y k·∫øt qu·∫£
        car_info = check_car_info(bsx)

        # Ki·ªÉm tra n·∫øu c√≥ vi ph·∫°m
        if car_info.get('totalViolations', 0) > 0:
            # L·∫•y th√¥ng tin vi ph·∫°m ƒë·∫ßu ti√™n
            violation = car_info['violations'][0]

            # Tr√≠ch xu·∫•t th√¥ng tin t·ª´ JSON
            bien_so = violation.get('bien_kiem_sat', 'N/A')
            trang_thai = violation.get('trang_thai', 'N/A')
            mau_bien = violation.get('mau_bien', 'N/A')
            loai_phuong_tien = violation.get('loai_phuong_tien', 'N/A')
            thoi_gian_vi_pham = violation.get('thoi_gian_vi_pham', 'N/A')
            dia_diem_vi_pham = violation.get('dia_diem_vi_pham', 'N/A')
            hanh_vi_vi_pham = violation.get('hanh_vi_vi_pham', 'N/A')
            don_vi_phat_hien_vi_pham = violation.get('don_vi_phat_hien_vi_pham', 'N/A')
            noi_giai_quyet_vu_viec = violation.get('noi_giai_quyet_vu_viec', 'N/A').replace('\\n', '\n')  # X·ª≠ l√Ω \n trong JSON
            so_dien_thoai = violation.get('so_dien_thoai', 'N/A')
            muc_phat = violation.get('muc_phat', 'N/A')

            # ƒê·ªãnh d·∫°ng tin nh·∫Øn
            message_text = f'''
<blockquote expandable>‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅùôèùôùùô§ÃÇùô£ùôú ùô©ùôûùô£ ùô´ùôû ùô•ùôùùôñÃ£ùô¢‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚îó‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îõ
¬ª Bi·ªÉn s·ªë: {bien_so}

¬ª Tr·∫°ng th√°i: {trang_thai}

¬ª M√†u bi·ªÉn: {mau_bien}

¬ª Lo·∫°i ph∆∞∆°ng ti·ªán: {loai_phuong_tien}

¬ª Th·ªùi gian vi ph·∫°m: {thoi_gian_vi_pham}

¬ª ƒê·ªãa ƒëi·ªÉm vi ph·∫°m: {dia_diem_vi_pham}

¬ª H√†nh vi vi ph·∫°m: {hanh_vi_vi_pham}

¬ª ƒê∆°n v·ªã ph√°t hi·ªán vi ph·∫°m: {don_vi_phat_hien_vi_pham}

¬ª N∆°i gi·∫£i quy·∫øt v·ª• vi·ªác: {noi_giai_quyet_vu_viec}</blockquote>'''

            # G·ª≠i tin nh·∫Øn v·ªõi th√¥ng tin
            bot.send_message(message.chat.id, {message_text}, parse_mode="HTML")

        else:
            bot.send_message(message.chat.id, f"<blockquote>Bi·ªÉn s·ªë xe {bsx} kh√¥ng c√≥ l·ªói vi ph·∫°m.</blockquote>", parse_mode="HTML")

    except IndexError:
        bot.send_message(message.chat.id, "Vui l√≤ng nh·∫≠p bi·ªÉn s·ªë xe. V√≠ d·ª•: /bsx 24A14307")
    except Exception as e:
        bot.send_message(message.chat.id, f"L·ªói: {str(e)}")


@bot.message_handler(commands=['voice'])
def text_to_voice(message):
    # L·∫•y n·ªôi dung vƒÉn b·∫£n sau l·ªánh /voice
    text = message.text[len('/voice '):].strip()

    # N·∫øu kh√¥ng c√≥ vƒÉn b·∫£n, tr·∫£ l·ªùi h∆∞·ªõng d·∫´n s·ª≠ d·ª•ng
    if not text:
        bot.reply_to(message, "ü§ñ Tqhuy-BOT\nUsage: /voice <Text>")
        return

    # T·∫°o t·ªáp t·∫°m th·ªùi ƒë·ªÉ l∆∞u file .mp3 v·ªõi t√™n "elven"
    temp_file_path = tempfile.mktemp(suffix='elven.mp3')

    try:
        # Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i b·∫±ng gTTS
        tts = gTTS(text, lang='vi')
        tts.save(temp_file_path)

        # M·ªü v√† g·ª≠i file √¢m thanh .mp3 v·ªõi t√™n "elven"
        with open(temp_file_path, 'rb') as audio_file:
            bot.send_voice(chat_id=message.chat.id, voice=audio_file)

    except Exception as e:
        bot.reply_to(message, "ü§ñ Tqhuy-BOT\nError Bot")
    
    finally:
        # X√≥a t·ªáp √¢m thanh t·∫°m th·ªùi sau khi g·ª≠i
        if os.path.exists(temp_file_path):
            os.remove(temp_file_path)

@bot.message_handler(commands=['qr'])
def generate_qr(message):
    # T√°ch t·ª´ kh√≥a nh·∫≠p v√†o l·ªánh
    input_text = message.text.split(maxsplit=1)
    
    if len(input_text) > 1:
        input_text = input_text[1]  # L·∫•y ph·∫ßn t·ª´ kh√≥a sau /qr
        # T·∫°o QR code
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=4,
        )
        qr.add_data(input_text)
        qr.make(fit=True)
        
        img = qr.make_image(fill='black', back_color='white')
        bio = BytesIO()
        bio.name = 'qr.png'
        img.save(bio, 'PNG')
        bio.seek(0)

        # G·ª≠i ·∫£nh QR t·ªõi ng∆∞·ªùi d√πng
        bot.send_photo(message.chat.id, photo=bio, caption=f"<blockquote>QR c·ªßa ch·ªØ: {input_text}</blockquote>",parse_mode="HTML")
    else:
        bot.reply_to(message, "ü§ñ Tqhuy-BOT\nü§ñ Usage: /qr <Ch·ªØ C·∫ßn T·∫°o QR>")


# S·ª≠ l√≠ GetKey
from datetime import datetime

def TimeStamp():
    now = datetime.now().date()  # ƒê√∫ng c√°ch l·∫•y ng√†y hi·ªán t·∫°i
    return now

def get_time_vietnam():
    return datetime.datetime.now().strftime("%d-%m-%Y %H:%M:%S")

def init_db():
    connection = sqlite3.connect('users.db', check_same_thread=False)
    cursor = connection.cursor()
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            key TEXT,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    """)
    connection.commit()
    connection.close()

init_db()


# Thi·∫øt l·∫≠p c∆° s·ªü d·ªØ li·ªáu
def setup_database():
    connection = sqlite3.connect('users.db', check_same_thread=False)
    cursor = connection.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            user_id INTEGER PRIMARY KEY,
            key TEXT,
            has_used_key INTEGER DEFAULT 0
        )
    ''')
    connection.commit()
    connection.close()

setup_database()


print("truongdeptraivcll ƒë√£  ƒëang ho·∫°t ƒë·ªông")
@bot.message_handler(commands=['ngl'])
def send_ngl_message(message):
    try:
        args = message.text.split(' ', 3)
        if len(args) < 4:
            bot.reply_to(message, "‚ö†Ô∏è Vui l√≤ng cung c·∫•p username, message, v√† amount. S·ª≠ d·ª•ng: /ngl {username} {message} {amount}")
            return

        # Extract parameters from the message
        username = args[1]
        message_text = args[2]
        amount = args[3]

        # Call the API with provided parameters
        response = send_api_request(username, message_text, amount)
        
        if response.status_code == 200:
            bot.reply_to(message, f"‚úÖ Th√¥ng ƒëi·ªáp ƒë√£ ƒë∆∞·ª£c g·ª≠i th√†nh c√¥ng ƒë·∫øn `{username}`.")
        else:
            bot.reply_to(message, f"‚ùå C√≥ l·ªói x·∫£y ra khi g·ª≠i tin nh·∫Øn: {response.text}")

    except Exception as e:
        bot.reply_to(message, f"‚ùå C√≥ l·ªói x·∫£y ra: {e}")

def send_api_request(username, message_text, amount):
    # Format the URL with parameters
    url = API_URL.format(username=username, message=message_text, amount=amount)
    response = requests.get(url)
    return response


@bot.message_handler(commands=['getkey'])
def startkey(message):
    bot.reply_to(message, text='Ch·ªù ƒëi ƒë·ªãt m·∫π m√†y!')
    today = datetime.now().date()  # L·∫•y ng√†y h√¥m nay
    key = "truong" + str(int(message.from_user.id) * int(today.day) - 12666)
    key = "https://xuantruong.x10.mx/key.html?key=" + key
    api_token = '57c63df502654edce2a31052a45d72fa29e49cc17bd6db0ec88ded91dff0cb00'
    
    try:
        response = requests.get(f'https://yeumoney.com/QL_api.php?token={api_token}&format=json&url={key}')
        url = response.json()

        # Check if the 'shortenedUrl' key exists in the response JSON
        if 'shortenedUrl' in url:
            url_key = url['shortenedUrl']
        else:
            bot.reply_to(message, 'Kh√¥ng t√¨m th·∫•y shortenedUrl trong ph·∫£n h·ªìi.')
            return

    except requests.RequestException as e:
        bot.reply_to(message, 'ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi ƒë·∫øn API.')
        print(f"Request error: {e}")
        return

    text = f'''
- LINK L·∫§Y KEY C·ª¶A @{message.from_user.username} NG√ÄY {today} L√Ä: {url_key} 
- KHI L·∫§Y KEY XONG, D√ôNG L·ªÜNH /key <key> ƒê·ªÇ TI·∫æP T·ª§C -
    '''
    bot.reply_to(message, text)
@bot.message_handler(commands=['plan'])
def check_plan(message):
    user_id = message.from_user.id

    # Ki·ªÉm tra tr·∫°ng th√°i "ƒë√£ get"
    if user_id in used_getkey_users:
        key_status = " ƒê√£ /getkey "
    else:
        key_status = " Ch∆∞a /getkey "

    # Ki·ªÉm tra VIP qua th∆∞ m·ª•c
    vip_file_path = os.path.join(vip_folder_path, f"{user_id}.txt")
    if os.path.exists(vip_file_path):
        vip_status = " ƒê√£ Mua Vip "
    else:
        vip_status = " Ch∆∞a Mua Vip "

    # Tr·∫£ v·ªÅ k·∫øt qu·∫£
    plan_message = f"""<blockquote> Name Bot : [ @ddoslo_bot ]
    th·∫±ng √≥c l t√™n @{message.from_user.username}
    _______________________________________________________
    Tr·∫°ng th√°i Free : /spam  c·ªßa b·∫°n : [ {key_status} ] 
    _______________________________________________________
    Tr·∫°ng th√°i VIP  : /smsvip /spamvip [ {vip_status} ] </blockquote>"""
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
      types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),
        
    )

    video_url = "https://files.catbox.moe/xbgx14.mp4"
    bot.send_video(message.chat.id, video_url, caption=plan_message, parse_mode='HTML', reply_markup=keyboard)
    

# T·∫°o th∆∞ m·ª•c VIP n·∫øu ch∆∞a t·ªìn t·∫°i
if not os.path.exists(vip_folder_path):
    os.makedirs(vip_folder_path)


import string

# ƒê·∫£m b·∫£o th∆∞ m·ª•c ./user t·ªìn t·∫°i
if not os.path.exists('./user'):
    os.makedirs('./user')

# T·∫°o m·ªôt key ng·∫´u nhi√™n
def generate_key():
    """T·∫°o m·ªôt key ng·∫´u nhi√™n g·ªìm 16 k√Ω t·ª± (ch·ªØ v√† s·ªë)."""
    key = ''.join(random.choices(string.ascii_uppercase + string.digits, k=16))
    return key

# L∆∞u key v√† th·ªùi gian h·∫øt h·∫°n v√†o t·ªáp tin c·ªßa ng∆∞·ªùi d√πng
def save_key_for_user(user_id, key, expiry):
    """L∆∞u key v√† th·ªùi gian h·∫øt h·∫°n v√†o t·ªáp c·ªßa ng∆∞·ªùi d√πng."""
    user_file = f'./user/{user_id}_key.txt'
    
    # L∆∞u th√¥ng tin key v√† h·∫°n s·ª≠ d·ª•ng v√†o t·ªáp
    with open(user_file, 'w', encoding='utf-8') as file:
        file.write(f'Key: {key}\nExpiry: {expiry.strftime("%H:%M %d-%m-%Y")}\n')
    
    return user_file  # Tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n t·ªáp v·ª´a l∆∞u


@bot.message_handler(commands=['taokey'])
def create_key(message):
    if str(message.from_user.id) == ADMIN_ID:
        try:
            command_parts = message.text.split(' ', 2)  # T√°ch th√†nh ba ph·∫ßn: l·ªánh, m√£ th·∫ª, th·ªùi gian
            if len(command_parts) < 3:
                bot.reply_to(message, "Vui l√≤ng nh·∫≠p m√£ th·∫ª v√† th·ªùi gian h·∫øt h·∫°n. V√≠ d·ª•: /taokey 123123 23:00 2-2-2024")
                return

            # L·∫•y m√£ th·∫ª v√† th·ªùi gian
            card_serial = command_parts[1]
            expiry_time_str = command_parts[2]
            
            # Chuy·ªÉn ƒë·ªïi th·ªùi gian t·ª´ chu·ªói th√†nh ƒë·ªëi t∆∞·ª£ng datetime
            expiry = datetime.strptime(expiry_time_str, '%H:%M %d-%m-%Y')

            # T·∫°o key ng·∫´u nhi√™n
            new_key = generate_key()

            # L∆∞u key v√†o t·ªáp cho ng∆∞·ªùi d√πng (admin c√≥ th·ªÉ l∆∞u key cho ng∆∞·ªùi kh√°c n·∫øu c·∫ßn)
            save_key_for_user(message.from_user.id, new_key, expiry)

            # G·ª≠i th√¥ng b√°o cho admin v·ªÅ key m·ªõi
            bot.send_message(ADMIN_ID, f"Admin {message.from_user.username} ƒë√£ t·∫°o key:\n"
                                       f"Key: {new_key}\n"
                                       f"Serial: {card_serial}\n"
                                       f"H·∫°n s·ª≠ d·ª•ng: {expiry.strftime('%H:%M %d-%m-%Y')}\n")

            # Ph·∫£n h·ªìi cho admin
            bot.reply_to(message, f"Key ƒë√£ ƒë∆∞·ª£c t·∫°o: {new_key}\nSerial: {card_serial}\nH·∫°n s·ª≠ d·ª•ng: {expiry.strftime('%H:%M %d-%m-%Y')}")
            
        except Exception as e:
            bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫°o key: {e}")
    else:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

@bot.message_handler(commands=['key'])
def key(message):
    # Split the message and check if the key argument is provided
    if len(message.text.split()) != 2:
        bot.reply_to(message, 'VUI L√íNG NH·∫¨P KEY ƒê√öNG ƒê·ªäNH D·∫†NG: /key <key>')
        return

    user_id = message.from_user.id
    key = message.text.split()[1]
    today = datetime.now().date()  # L·∫•y ng√†y h√¥m nay
    expected_key = "truong" + str(int(user_id) * int(today.day) - 12666)

    # Log the expected and user-entered keys for debugging
    print(f"Expected key: {expected_key}")
    print(f"User-entered key: {key}")
    
    # Compare the key entered by the user with the expected key
    if key == expected_key:
        bot.reply_to(message, 'KEY H·ª¢P L·ªÜ. B·∫†N ƒê√É ƒê∆Ø·ª¢C PH√âP S·ª¨ D·ª§NG L·ªÜNH /spam.')
        
        # Ensure the directory exists before writing to the file
        file_path = f'./user/{today.day}/{user_id}.txt'
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        
        # Write an empty file to indicate that the key is valid
        with open(file_path, "w") as fi:
            fi.write("")  # Can add more data to the file if needed
    else:
        bot.reply_to(message, 'KEY KH√îNG H·ª¢P L·ªÜ.')


@bot.message_handler(commands=['spam'])
def spam(message):
    user_id = message.from_user.id
    today = date.today()
    
    user_directory = f"./user/{today.day}/"
    user_file_path = os.path.join(user_directory, f"{user_id}.txt")

    # Check if the directory exists, create if not
    if not os.path.exists(user_directory):
        os.makedirs(user_directory)

    if not os.path.exists(user_file_path):
        bot.reply_to(message, '*Vui l√≤ng GET KEY c·ªßa ng√†y h√¥m nay* -D√πng /getkey ƒë·ªÉ l·∫•y key v√† d√πng /key ƒë·ªÉ nh·∫≠p key h√¥m nay.')
        return

    # Check for phone number and spam count
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'VUI L√íNG NH·∫¨P S·ªê ƒêI·ªÜN THO·∫†I')
        return

    phone_number = message.text.split()[1]
    
    # Validate phone number format
    if not re.search(r"^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$", phone_number):
        bot.reply_to(message, 'S·ªê ƒêI·ªÜN THO·∫†I KH√îNG H·ª¢P L·ªÜ !')
        return

    # Block specific phone numbers (e.g., admin's number)
    if phone_number in ["0377323188"]:
        bot.reply_to(message, "Spam s√¥ÃÅ admin aÃÄ tao ban maÃÄy gi∆°ÃÄ üòæ")
        return

    # Paths to external scripts
    script_files = ["text1.py", "text2.py", "text3.py", "text4.py"]

    # Cooldown mechanism (120 seconds per user)
    username = message.from_user.username
    current_time = time.time()

    # Check if user is within cooldown period
    if username in cooldown_dict and current_time - cooldown_dict[username].get('free', 0) < 220:
        remaining_time = int(220 - (current_time - cooldown_dict[username].get('free', 0)))
        bot.reply_to(message, f"@{username} Vui l√≤ng ƒë·ª£i {remaining_time} gi√¢y tr∆∞·ªõc khi s·ª≠ d·ª•ng l·∫°i l·ªánh /spam.")
        return
    
    # Update cooldown dictionary
    cooldown_dict[username] = {'free': current_time}

    # Execute external scripts concurrently
    for script_file in script_files:
        script_path = os.path.join(os.getcwd(), script_file)
        process = subprocess.Popen(["python", script_path, phone_number, "2"])
        processes.append(process)

    # Timestamp for the message
    thoigian = dt.now().strftime('%d-%m-%Y %H:%M:%S')
    
    # Video URL and message text
    
    xinchao = f"""<blockquote>
‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚™¢€∞€™€™€´€´‚óè€™€´€∞
‚îú‚™¢ü™™| Y√™u C·∫ßu B·ªüi: @{username}
‚îú‚™¢üöÄ| Tr·∫°ng Th√°i: Th√†nh C√¥ng
‚îú‚™¢‚è±| |TH·ªúI GIAN: concac
‚îú‚™¢ü™ß | G√ìI: MI·ªÑN PH√ç
‚îú‚™¢üëÆ‚Äç‚ôÇÔ∏è| Owner: @ngotk999
‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚™¢€∞€™€™€´€´‚óè€™€´€∞ 
</blockquote>
     """
    keyboard = types.InlineKeyboardMarkup(row_width=2)  
    keyboard.add(
      types.InlineKeyboardButton("üë§ Admin", url="https://t.me/ngotk999"),        
    )

    video_url = "https://files.catbox.moe/xbgx14.mp4"
    bot.send_video(message.chat.id, video_url, caption=xinchao, parse_mode='HTML', reply_markup=keyboard)

    # G·ª≠i tin nh·∫Øn "loading"
    sent_message = bot.reply_to(message, "ƒêang x·ª≠ l√Ω...")

    # Chu·ªói hi·ªáu ·ª©ng "Loading"
    
    loading_frames = [
        "Buy G√å C·ª© Ib @ngotk999 dcu ",
        "c√°i ƒë·ªãt m·∫π m√†y  ...",        
    ]
    

    # Hi·ªáu ·ª©ng "Loading"
    for _ in range(1):  # L·∫∑p 3 l·∫ßn hi·ªáu ·ª©ng
        for frame in loading_frames:
            bot.edit_message_text(frame, chat_id=message.chat.id, message_id=sent_message.message_id)
            time.sleep(0.2)

    # C·∫≠p nh·∫≠t tr·∫°ng th√°i spam
    bot.edit_message_text(f"\n\n[ {filename} ] B·∫Øt ƒê·∫ßu Spam  {phone_number}  ", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(1)  # Ch·ªù tr∆∞·ªõc khi x√≥a

    # X√≥a tin nh·∫Øn c≈©
    bot.delete_message(message.chat.id, message.message_id)  # X√≥a tin nh·∫Øn l·ªánh g·ªëc
    bot.delete_message(message.chat.id, sent_message.message_id)  # X√≥a tin nh·∫Øn "loading"




def generate_key():
    return str(dt.now().strftime('%Y%m%d%H%M%S'))

# L∆∞u key cho ng∆∞·ªùi d√πng v√†o file
def save_key_for_user(user_id, key, expiry_time):
    user_directory = f"./user/keys/"
    if not os.path.exists(user_directory):
        os.makedirs(user_directory)

    with open(f"{user_directory}napthe.txt", "a") as f:
        f.write(f"{user_id} {key} {expiry_time}\n")

# T·∫£i key c·ªßa ng∆∞·ªùi d√πng
def load_key_for_user(user_id):
    try:
        with open("./user/keys/napthe.txt", "r") as f:
            for line in f.readlines():
                parts = line.split(" ")
                stored_user_id, key, expiry_time = parts[0], parts[1], parts[2]
                if stored_user_id == str(user_id):
                    return key, expiry_time
    except FileNotFoundError:
        return None, None
    return None, None

@bot.message_handler(commands=['taokey'])
def create_key(message):
    if str(message.from_user.id) == ADMIN_ID:
        try:
            command_parts = message.text.split(' ', 1)
            if len(command_parts) < 2:
                bot.reply_to(message, "Vui l√≤ng nh·∫≠p th·ªùi gian h·∫øt h·∫°n.")
                return

            expiry_time_str = command_parts[1]
            expiry = dt.strptime(expiry_time_str, '%H:%M %d-%m-%Y')

            new_key = generate_key()
            save_key_for_user(message.from_user.id, new_key, expiry)

            # G·ª≠i th√¥ng b√°o cho admin v·ªÅ key m·ªõi
            bot.send_message(ADMIN_ID, f"Admin {message.from_user.username} ƒë√£ t·∫°o key:\nKey: {new_key}\nH·∫°n s·ª≠ d·ª•ng: {expiry.strftime('%H:%M %d-%m-%Y')}")
            
            bot.reply_to(message, f"Key ƒë√£ ƒë∆∞·ª£c t·∫°o: {new_key}, H·∫°n s·ª≠ d·ª•ng: {expiry.strftime('%H:%M %d-%m-%Y')}")
        except Exception as e:
            bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫°o key: {e}")
    else:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")

@bot.message_handler(commands=['enkey'])
def set_key(message):
    user_id = message.from_user.id
    input_key = message.text.split()[1] if len(message.text.split()) > 1 else None

    if not input_key:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p key.')
        return

    # Ki·ªÉm tra key h·ª£p l·ªá
    key, _ = load_key_for_user(user_id)
    if key is None:
        bot.reply_to(message, "B·∫°n ch∆∞a c√≥ key h·ª£p l·ªá. Vui l√≤ng d√πng /taokey ƒë·ªÉ l·∫•y key.")
        return

    if input_key != key:
        bot.reply_to(message, "Key b·∫°n nh·∫≠p kh√¥ng h·ª£p l·ªá.")
        return

    expiry_time = dt.strptime(_, '%H:%M %d-%m-%Y')
    current_time = dt.now()

    if current_time > expiry_time:
        bot.reply_to(message, "Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng nh·∫≠p l·∫°i key m·ªõi.")
        return

    bot.reply_to(message, "Key h·ª£p l·ªá. B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng l·ªánh /spam.")

@bot.message_handler(commands=['spams'])
def spam(message):
    user_id = message.from_user.id
    today = date.today()

    user_directory = f"./user/{today.day}/"
    user_file_path = os.path.join(user_directory, f"{user_id}.txt")

    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng c√≥ key h·ª£p l·ªá ch∆∞a
    key, _ = load_key_for_user(user_id)
    if key is None:
        bot.reply_to(message, '*Vui l√≤ng GET KEY c·ªßa ng√†y h√¥m nay* -D√πng /taokey ƒë·ªÉ l·∫•y key v√† d√πng /key ƒë·ªÉ nh·∫≠p key h√¥m nay.')
        return

    # Ki·ªÉm tra xem ng∆∞·ªùi d√πng ƒë√£ nh·∫≠p s·ªë ƒëi·ªán tho·∫°i ch∆∞a
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'VUI L√íNG NH·∫¨P S·ªê ƒêI·ªÜN THO·∫†I')
        return

    phone_number = message.text.split()[1]

    # Ki·ªÉm tra ƒë·ªãnh d·∫°ng s·ªë ƒëi·ªán tho·∫°i
    if not re.search(r"^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$", phone_number):
        bot.reply_to(message, 'S·ªê ƒêI·ªÜN THO·∫†I KH√îNG H·ª¢P L·ªÜ !')
        return

    # Ki·ªÉm tra th·ªùi gian h·∫øt h·∫°n c·ªßa key
    expiry_time_str = _  # Gi·∫£ s·ª≠ ch√∫ng ta l·∫•y th·ªùi gian h·∫øt h·∫°n t·ª´ key ƒë√£ l∆∞u
    expiry_time = dt.strptime(expiry_time_str, '%H:%M %d-%m-%Y')
    current_time = dt.now()

    if current_time > expiry_time:
        bot.reply_to(message, "Key c·ªßa b·∫°n ƒë√£ h·∫øt h·∫°n. Vui l√≤ng nh·∫≠p l·∫°i key m·ªõi.")
        return

    # Block specific phone numbers (e.g., admin's number)
    if phone_number in ["0377323188"]:
        bot.reply_to(message, "Spam s√¥ÃÅ admin aÃÄ tao ban maÃÄy gi∆°ÃÄ üòæ")
        return

    # Ti·∫øn h√†nh spam
    bot.reply_to(message, f"ƒêang ti·∫øn h√†nh spam s·ªë {phone_number}...")

    # T·∫°o tin nh·∫Øn th√¥ng b√°o ƒë√£ spam
    bot.send_message(message.chat.id, f"ƒê√£ spam s·ªë {phone_number} th√†nh c√¥ng!")



    #free spam t·∫°o key


@bot.message_handler(commands=['stop_spam'])
def stop_spam(message):
    user_id = message.from_user.id
    username = message.from_user.username
    if len(message.text.split()) == 1:
        bot.reply_to(message, 'Vui L√≤ng Nh·∫≠p S·ªë ƒêi·ªán Tho·∫°i ƒê·ªÉ D·ª´ng Spam.')
        return
    phone_number = message.text.split()[1]
    stop_spam_for_phone(phone_number)
    video_url = "liemspam.000webhostapp.com/lon.mp4"
    bot.reply_to(message, f"""
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì {name_bot} ‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚îÇ¬ª User: @{username}                      
‚îÇ¬ª Stop: Success [‚úì]
‚îÇ¬ª Attacking: {phone_number}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    """)
    
def stop_spam_for_phone(phone_number):
    for process in processes:
        if phone_number in process.args:
            process.terminate()
            processes.remove(process)
import os

@bot.message_handler(commands=['addbasic'])
def addbasic(message):
    # Ensure admin access
    if message.from_user.id != ADMIN_ID:
        bot.reply_to(message, "B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    # Check if a user ID or username is provided
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi d√πng ho·∫∑c t√™n ƒëƒÉng nh·∫≠p ƒë·ªÉ th√™m.')
        return

    user_identifier = message.text.split()[1]

    # Ensure 'basic' folder exists
    basic_folder_path = "./basic"
    if not os.path.exists(basic_folder_path):
        os.makedirs(basic_folder_path)

    # Create a basic user file for the user
    basic_file_path = f"{basic_folder_path}/{user_identifier}.txt"
    if not os.path.exists(basic_file_path):  # Avoid overwriting existing user
        with open(basic_file_path, 'w') as file:
            file.write("basic_user")
        bot.reply_to(message, f"Ng∆∞·ªùi d√πng {user_identifier} ƒë√£ ƒë∆∞·ª£c th√™m v√†o danh s√°ch Basic.")
        print(f"Added user {user_identifier} to basic folder.")
    else:
        bot.reply_to(message, f"Ng∆∞·ªùi d√πng {user_identifier} ƒë√£ c√≥ trong danh s√°ch Basic r·ªìi.")
        print(f"User {user_identifier} already exists in basic folder.")


@bot.message_handler(commands=['spambasic'])
def spambasic(message):
    user_id = message.from_user.id
    username = message.from_user.username
    first_name = message.from_user.first_name or ""
    last_name = message.from_user.last_name or ""
    full_name = f"{first_name} {last_name}".strip()
    user_id = message.from_user.id
    basic_file_path = f"./basic/{user_id}.txt"

    # Check if user has access to use /spambasic
    if not os.path.exists(basic_file_path):
        bot.reply_to(message, "B·∫°n ch∆∞a c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y. Vui l√≤ng li√™n h·ªá admin.")
        return

    # Ensure phone number argument is provided
    if len(message.text.split()) < 2:
        bot.reply_to(message, 'Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªán tho·∫°i.')
        return

    phone_number = message.text.split()[1]

    # Validate phone number format
    if not re.search("^(0?)(3[2-9]|5[6|8|9]|7[0|6-9]|8[0-6|8|9]|9[0-4|6-9])[0-9]{7}$", phone_number):
        bot.reply_to(message, 'S·ªë ƒëi·ªán tho·∫°i kh√¥ng h·ª£p l·ªá!')
        return


    # Paths to external scripts
    script_files = ["text1.py", "text2.py", "text3.py", "text4.py", "text5.py", "text6.py", "text7.py", "text8.py", "text9.py", "text10.py"]
    
    # Execute external scripts without cooldown
    for script_file in script_files:
        script_path = os.path.join(os.getcwd(), script_file)
        subprocess.Popen(["python", script_path, phone_number, "50"])

    print(f"user vip User ID: {user_id}, Name: {full_name}, Phone: {phone_number}, Count: 100 ")
    # Send confirmation to user
    response = (
        f"Attack initiated üöÄ\n"
        f"+ Target number üì±: [{phone_number}]\n"
        f"+ Number of attacks üì±: [ 999 ]"
    )
    sent_message = bot.reply_to(message, response)
    bot.reply_to(message,response)
    # Short delay to ensure the bot has sent the reply
    # Wait for a moment before the next part of the "shattering" effect
    
    bot.edit_message_text(f"\n\n ! ", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    # Another effect stage (disintegration)
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading .", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(1)
    
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading .", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading .", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ..", chat_id=message.chat.id, message_id=sent_message.message_id)
    
    time.sleep(0.2)
    bot.edit_message_text(f"\n\n Loading ...", chat_id=message.chat.id, message_id=sent_message.message_id)
    time.sleep(0.2)

    bot.edit_message_text(f"\n\n[ {full_name} ] B·∫Øt ƒê·∫ßu Spam  {phone_number}  ", chat_id=message.chat.id, message_id=sent_message.message_id)
    # Another effect stage (disintegration)
    time.sleep(1)
    bot.delete_message(message.chat.id, message.message_id)  # Delete the original message
    bot.delete_message(sent_message.chat.id, sent_message.message_id)



@bot.message_handler(commands=['info'])
def handle_check(message):
    user = message.reply_to_message.from_user if message.reply_to_message else message.from_user
    
    # Hi·ªÉn th·ªã bi·ªÉu t∆∞·ª£ng ƒë·ª£i
    waiting = bot.reply_to(message, "üîé")
    
    # L·∫•y th√¥ng tin ng∆∞·ªùi d√πng
    user_photos = bot.get_user_profile_photos(user.id)
    chat_info = bot.get_chat(user.id)
    chat_member_status = bot.get_chat_member(message.chat.id, user.id).status
    
    bio = chat_info.bio or "Kh√¥ng c√≥ bio"
    user_first_name = user.first_name
    user_last_name = user.last_name or ""
    user_username = f"@{user.username}" if user.username else "Kh√¥ng c√≥ username"
    user_language = user.language_code or 'Kh√¥ng x√°c ƒë·ªãnh'
    
    # ƒê·ªãnh nghƒ©a tr·∫°ng th√°i ng∆∞·ªùi d√πng
    status_dict = {
        "creator": "Admin ch√≠nh",
        "administrator": "Admin",
        "member": "Th√†nh vi√™n",
        "restricted": "B·ªã h·∫°n ch·∫ø",
        "left": "R·ªùi nh√≥m",
        "kicked": "B·ªã ƒëu·ªïi kh·ªèi nh√≥m"
    }
    status = status_dict.get(chat_member_status, "Kh√¥ng x√°c ƒë·ªãnh")
    
    # So·∫°n tin nh·∫Øn g·ª≠i ƒëi
    caption = (
        "<pre>     üöÄ TH√îNG TIN üöÄ\n"
        "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ìINFO‚≠ì‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        f"‚îÇ¬ª üÜî: {user.id}\n"
        f"‚îÇ¬ª üë§T√™n: {user_first_name} {user_last_name}\n"
        f"‚îÇ¬ª üëâUsername: {user_username}\n"
        f"‚îÇ¬ª üî∞Ng√¥n ng·ªØ: {user_language}\n"
        f"‚îÇ¬ª üè¥Tr·∫°ng th√°i: {status}\n"
        f"‚îÇ¬ª ‚úçÔ∏èBio: {bio}\n"
        f"‚îÇ¬ª ü§≥Avatar: {'ƒê√£ c√≥ avatar' if user_photos.total_count > 0 else 'Kh√¥ng c√≥ avatar'}\n"
        "‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ[‚úì]‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</pre>"
    )
    
    # G·ª≠i ·∫£nh ho·∫∑c tin nh·∫Øn vƒÉn b·∫£n
    if user_photos.total_count > 0:
        bot.send_photo(message.chat.id, user_photos.photos[0][-1].file_id, caption=caption, parse_mode='HTML', reply_to_message_id=message.message_id)
    else:
        bot.reply_to(message, caption, parse_mode='HTML')
    
    # X√≥a tin nh·∫Øn ch·ªù sau khi ho√†n t·∫•t
    def xoatn(message, delay):
        try:
            bot.delete_message(message.chat.id, waiting.message_id)
        except Exception as e:
            print(f"L·ªói khi x√≥a tin nh·∫Øn: {e}")
    
    threading.Thread(target=xoatn, args=(message, 0)).start()

@bot.message_handler(commands=['check'])
def check_hot_web(message):
    # Ki·ªÉm tra xem l·ªánh c√≥ ƒë·ªß tham s·ªë kh√¥ng (URL c·ªßa trang web c·∫ßn ki·ªÉm tra)
    if len(message.text.split()) < 2:
        bot.reply_to(message, '<blockquote>Vui l√≤ng cung c·∫•p URL c·ªßa trang web c·∫ßn ki·ªÉm tra (VD: /check https://example.com).</blockquote>',parse_mode='HTML')
        return
    
    # L·∫•y URL t·ª´ l·ªánh
    url = message.text.split()[1]

    try:
        # G·ª≠i y√™u c·∫ßu HTTP GET ƒë·∫øn URL
        response = requests.get(url, timeout=10)
        
        # Ki·ªÉm tra tr·∫°ng th√°i c·ªßa trang web
        if response.status_code == 200:
            bot.reply_to(message, f"<blockquote>üîó Trang web {url} ƒëang ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng (Status: 200 OK).</blockquote>", parse_mode='HTML')
        else:
            bot.reply_to(message, f"<blockquote>‚ö†Ô∏è Trang web {url} c√≥ v·∫•n ƒë·ªÅ (Status: {response.status_code}).</blockquote>", parse_mode='HTML')
    except requests.exceptions.RequestException as e:
        # X·ª≠ l√Ω l·ªói n·∫øu kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi trang web
        bot.reply_to(message, f"<blockquote>‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi trang web {url}. L·ªói: {e}</blockquote>", parse_mode='HTML')

@bot.message_handler(commands=['checkip'])
def check_ip(message):
    # L·∫•y c√°c tham s·ªë t·ª´ l·ªánh
    params = message.text.split()
    
    if len(params) < 2:
        bot.reply_to(message, 'Vui l√≤ng cung c·∫•p ƒë·ªãa ch·ªâ IP c·∫ßn ki·ªÉm tra (VD: /checkip 8.8.8.8).')
        return
    
    ip_address = params[1]

    try:
        # G·ª≠i y√™u c·∫ßu t·ªõi d·ªãch v·ª• API ƒë·ªÉ l·∫•y th√¥ng tin chi ti·∫øt v·ªÅ ƒë·ªãa ch·ªâ IP
        response = requests.get(f'https://ipinfo.io/{ip_address}/json', timeout=10)
        response.raise_for_status()  # Ki·ªÉm tra l·ªói HTTP
        
        # L·∫•y d·ªØ li·ªáu t·ª´ ph·∫£n h·ªìi
        ip_data = response.json()

        # Tr√≠ch xu·∫•t th√¥ng tin chi ti·∫øt
        city = ip_data.get('city', 'Kh√¥ng x√°c ƒë·ªãnh')
        region = ip_data.get('region', 'Kh√¥ng x√°c ƒë·ªãnh')
        country = ip_data.get('country', 'Kh√¥ng x√°c ƒë·ªãnh')
        org = ip_data.get('org', 'Kh√¥ng x√°c ƒë·ªãnh')
        loc = ip_data.get('loc', 'Kh√¥ng x√°c ƒë·ªãnh')
        
        # T·∫°o th√¥ng tin ƒë·ªÉ g·ª≠i cho ng∆∞·ªùi d√πng
        ip_info = (f"<blockquote>üåê ƒê·ªãa ch·ªâ IP: {ip_address}\n"
                   f"üìç Th√†nh ph·ªë: {city}\n"
                   f"üèõ Khu v·ª±c: {region}\n"
                   f"üåé Qu·ªëc gia: {country}\n"
                   f"üè¢ T·ªï ch·ª©c: {org}\n"
                   f"üìç V·ªã tr√≠ (Lat, Lng): {loc}</blockquote>")
        
        # G·ª≠i th√¥ng tin ƒë·ªãa ch·ªâ IP t·ªõi ng∆∞·ªùi d√πng
        bot.reply_to(message, ip_info, parse_mode='HTML')
    except requests.exceptions.RequestException as e:
        # X·ª≠ l√Ω l·ªói n·∫øu kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn d·ªãch v·ª• API
        bot.reply_to(message, f"<blockquote>‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi d·ªãch v·ª• ki·ªÉm tra IP. L·ªói: {e}</pre>", parse_mode='blockquote')
    except Exception as e:
        # X·ª≠ l√Ω c√°c l·ªói kh√°c
        bot.reply_to(message, f"<blockquote>‚ùå ƒê√£ x·∫£y ra l·ªói khi ki·ªÉm tra IP. L·ªói: {e}</pre>", parse_mode='blockquote')

@bot.message_handler(commands=['html'])
def handle_code_command(message):
    # T√°ch l·ªánh v√† URL t·ª´ tin nh·∫Øn
    command_args = message.text.split(maxsplit=1)

    # Ki·ªÉm tra xem URL c√≥ ƒë∆∞·ª£c cung c·∫•p kh√¥ng
    if len(command_args) < 2:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p url sau l·ªánh /html. V√≠ d·ª•: /html https://example.com")
        return

    url = command_args[1]
    
    # Ki·ªÉm tra xem URL c√≥ h·ª£p l·ªá kh√¥ng
    parsed_url = urlparse(url)
    if not parsed_url.scheme or not parsed_url.netloc:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p m·ªôt URL h·ª£p l·ªá.")
        return

    domain = parsed_url.netloc
    file_name = f"tqhuygethtml.txt"
    
    try:
        # L·∫•y n·ªôi dung HTML t·ª´ URL
        response = requests.get(url)
        response.raise_for_status()  # X·∫£y ra l·ªói n·∫øu c√≥ l·ªói HTTP

        # L∆∞u n·ªôi dung HTML v√†o file
        with open(file_name, 'w', encoding='utf-8') as file:
            file.write(response.text)

        # ƒê·ªãnh d·∫°ng HTML v√† g·ª≠i file v·ªÅ ng∆∞·ªùi d√πng
        with open(file_name, 'rb') as file:
            caption = f"<blockquote>HTML c·ªßa trang web:\n{url}</blockquote>"
            bot.send_document(message.chat.id, file, caption=caption, parse_mode='HTML')

    except requests.RequestException as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi t·∫£i trang web: {e}")

    except Exception as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi x·ª≠ l√Ω file: {e}")

    finally:
        # ƒê·∫£m b·∫£o x√≥a file sau khi g·ª≠i
        if os.path.exists(file_name):
            try:
                os.remove(file_name)
            except Exception as e:
                bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi x√≥a file: {e}")


#s·ª≠ l√≠ l·ªánh m·ªü m√µm v√† kh√≥a m√µ
@bot.message_handler(commands=['im'])
def warn_user(message):
    user_id = message.from_user.id
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ch·ª©a th√¥ng tin c·∫ßn thi·∫øt kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>∆† !!!</blockquote>', parse_mode='HTML')
        return

    user_id = message.reply_to_message.from_user.id
    
    try:
        # C·∫•m chat ng∆∞·ªùi d√πng trong 15 ph√∫t
        until_date = int(time.time()) + 15 * 60
        bot.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=user_id,
            can_send_messages=False,
            can_send_media_messages=False,
            can_send_polls=False,
            can_send_other_messages=False,
            can_add_web_page_previews=False,
            until_date=until_date
        )
        
        # G·ª≠i tin nh·∫Øn th√¥ng b√°o ng∆∞·ªùi d√πng ƒë√£ b·ªã c·∫•m chat trong 15 ph√∫t
        bot.send_message(
            message.chat.id, 
            f"<blockquote>‚ö†Ô∏è Ng∆∞·ªùi d√πng v·ªõi ID {user_id} ƒë√£ b·ªã c·∫£nh b√°o v√† c·∫•m chat trong 15 ph√∫t.</blockquote>",
            parse_mode='HTML'
        )
    except Exception as e:
        # N·∫øu c√≥ l·ªói x·∫£y ra
        bot.reply_to(message, "<blockquote>Kh√¥ng th·ªÉ c·∫£nh b√°o ng∆∞·ªùi d√πng. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c quy·ªÅn h·∫°n c·ªßa bot.</blockquote>", parse_mode='HTML')
        print(f"Error warning user: {e}")

@bot.message_handler(commands=['unim'])
def unrestrict_user(message):
    user_id = message.from_user.id
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ch·ª©a th√¥ng tin c·∫ßn thi·∫øt kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>Vui l√≤ng tr·∫£ l·ªùi tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng c·∫ßn h·ªßy c·∫•m chat.</blockquote>', parse_mode='HTML')
        return

    user_id = message.reply_to_message.from_user.id
    
    try:
        # G·ª° b·ªè h·∫°n ch·∫ø chat cho ng∆∞·ªùi d√πng
        bot.restrict_chat_member(
            chat_id=message.chat.id,
            user_id=user_id,
            can_send_messages=True,
            can_send_media_messages=True,
            can_send_polls=True,
            can_send_other_messages=True,
            can_add_web_page_previews=True,
            until_date=0  # Kh√¥ng c·∫•m chat n·ªØa
        )
        
        # G·ª≠i tin nh·∫Øn th√¥ng b√°o ng∆∞·ªùi d√πng ƒë√£ ƒë∆∞·ª£c ph√©p chat tr·ªü l·∫°i
        bot.send_message(
            message.chat.id, 
            f"<blockquote>‚úÖ Ng∆∞·ªùi d√πng v·ªõi ID {user_id} ƒë√£ ƒë∆∞·ª£c ph√©p chat tr·ªü l·∫°i.</blockquote>", 
            parse_mode='HTML'
        )
    except Exception as e:
        # N·∫øu c√≥ l·ªói x·∫£y ra
        bot.reply_to(message, '<blockquote>Kh√¥ng th·ªÉ g·ª° c·∫•m chat cho ng∆∞·ªùi d√πng. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c quy·ªÅn h·∫°n c·ªßa bot.</blockquote>', parse_mode='HTML')
        print(f"Error unrestricted user: {e}")

@bot.message_handler(commands=['ban'])
def ban_user(message):
    user_id = message.from_user.id
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return
    
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ch·ª©a th√¥ng tin c·∫ßn thi·∫øt kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>........</blockquote>', parse_mode='HTML')
        return

    user_id = message.reply_to_message.from_user.id
    
    try:
        # Bot th·ª±c hi·ªán l·ªánh ban ng∆∞·ªùi d√πng
        bot.kick_chat_member(message.chat.id, user_id)
        
        # G·ª≠i tin nh·∫Øn th√¥ng b√°o ng∆∞·ªùi d√πng ƒë√£ b·ªã ban
        bot.send_message(
            message.chat.id, 
            f"<blockquote>üî® Ng∆∞·ªùi d√πng v·ªõi ID {user_id} ƒë√£ b·ªã ban kh·ªèi nh√≥m.</blockquote>",
            parse_mode='HTML'
        )
    except Exception as e:
        # N·∫øu c√≥ l·ªói x·∫£y ra
     bot.reply_to(message, '<blockquote>Kh√¥ng th·ªÉ ban ng∆∞·ªùi d√πng. Vui l√≤ng ki·ªÉm tra l·∫°i th√¥ng tin ho·∫∑c quy·ªÅn h·∫°n c·ªßa bot.</blockquote>', parse_mode='HTML')

bot_active = True

from datetime import datetime
from io import BytesIO

@bot.message_handler(commands=['tiktok'])
def tiktok_download(message):
    try:
        waiting_message = bot.reply_to(message, '‚å®Ô∏è ƒêang t·∫£i video...')

        url = message.text.split(' ')[1]
        api_url = f"https://subhatde.id.vn/tiktok/downloadvideo?url={url}"
        
        response = requests.get(api_url)
        data = response.json()
        
        if data['code'] == 0:
            video_data = data['data']
            author = video_data.get('author', {})

            title = video_data.get('title', 'Kh√¥ng c√≥ ti√™u ƒë·ªÅ')
            region = video_data.get('region', 'Kh√¥ng r√µ khu v·ª±c')
            play_url = video_data.get('play', 'Kh√¥ng c√≥ URL ph√°t video')
            music_url = video_data.get('music', 'Kh√¥ng c√≥ URL nh·∫°c')
            create_time = video_data.get('create_time', 0)
            nickname = author.get('nickname', 'Kh√¥ng c√≥ t√™n t√°c gi·∫£')

            create_time_formatted = datetime.utcfromtimestamp(create_time).strftime('%H:%M:%S | %d/%m/%Y')

            haha = (
                f"<b>üé• {title}</b>\n\n"
                f"<blockquote>\n"
                f"üìÖ Ng√†y ƒêƒÉng: {create_time_formatted}\n\n"
                f"üë§ <b>T√°c gi·∫£:</b> {nickname}\n"
                f"üåç <b>Khu V·ª±c:</b> {region}\n"
                f"‚è±Ô∏è <b>ƒê·ªô D√†i Video:</b> {video_data.get('duration', 'Kh√¥ng r√µ')} Gi√¢y\n\n"
                f"üëÅ <b>Views:</b> {video_data.get('play_count', 0):,}\n"
                f"‚ù§Ô∏è <b>Likes:</b> {video_data.get('digg_count', 0):,}\n"
                f"üí¨ <b>Comments:</b> {video_data.get('comment_count', 0):,}\n"
                f"üîó <b>Shares:</b> {video_data.get('share_count', 0):,}\n"
                f"üì• <b>Downloads:</b> {video_data.get('download_count', 0):,}\n"
                f"üìë <b>L∆∞u v√†o b·ªô s∆∞u t·∫≠p:</b> {video_data.get('collect_count', 0):,}\n"
                f"</blockquote>"
                f"üéµ <a href='{music_url}'>Nh·∫°c By Video</a>"
            )

            # Send video
            bot.send_video(chat_id=message.chat.id, video=play_url, caption=haha, parse_mode='HTML')

            # Send audio
            music_response = requests.get(music_url)
            audio_data = BytesIO(music_response.content)
            audio_data.seek(0)
            bot.send_audio(message.chat.id, audio_data, title="Nh·∫°c n·ªÅn t·ª´ video", performer=nickname)

        else:
            bot.send_message(message.chat.id, "Kh√¥ng th·ªÉ l·∫•y th√¥ng tin video t·ª´ TikTok.")
        
    except Exception as e:
        bot.send_message(message.chat.id, f"ƒê√£ c√≥ l·ªói x·∫£y ra: {str(e)}")
    finally:
        # Ensure the waiting message is deleted whether there's an error or not
        try:
            bot.delete_message(message.chat.id, waiting_message.message_id)
        except Exception:
            pass


AVATAR_NAMES = {
    102000012: "Chi·∫øn binh huy·ªÅn tho·∫°i",
    102000013: "Anh h√πng √°nh s√°ng",
}

CLOTHES_NAMES = {
    "211000000": "√Åo gi√°p s·∫Øt",
    "205000646": "Qu·∫ßn chi·∫øn binh",
    "211000168": "M≈© quy·ªÅn nƒÉng",
    "204000523": "Gi√†y th·∫ßn t·ªëc",
}

# X·ª≠ l√Ω l·ªánh /ff
@bot.message_handler(commands=['ff'])
def send_gai_image(message):
    chat_id = message.chat.id

    # L·∫•y tham s·ªë ID t·ª´ tin nh·∫Øn
    command_parts = message.text.split()
    if len(command_parts) < 2:
        bot.reply_to(message, "Vui l√≤ng cung c·∫•p ID! C√∫ ph√°p: /ff <id>")
        return

    input_id = command_parts[1]  # L·∫•y ID t·ª´ tham s·ªë
    api_url = f"https://elevenbotbythaihoc.us.kg/api/apiff.php/?id={input_id}&key=freeth"

    try:
        # G·ª≠i y√™u c·∫ßu API
        response = requests.get(api_url)
        response.raise_for_status()  # Ki·ªÉm tra l·ªói HTTP
        data = response.json()  # Gi·∫£ s·ª≠ API tr·∫£ v·ªÅ JSON

        if not data.get("error"):
            basic_info = data.get("data", {}).get("basicInfo", {})
            profile_info = data.get("data", {}).get("profileInfo", {})
            pet_info = data.get("data", {}).get("petInfo", {})
            social_info = data.get("data", {}).get("socialInfo", {})

            # ƒê·ªãnh d·∫°ng th√¥ng tin
            result = (
                f"*K·∫øt qu·∫£ t·ª´ API:*\n\n"
                f"üìÑ *Th√¥ng tin c∆° b·∫£n:*\n"
                f"- Account ID: `{basic_info.get('accountId', 'N/A')}`\n"
                f"- T√™n nh√¢n v·∫≠t: `{basic_info.get('nickname', 'N/A')}`\n"
                f"- Khu v·ª±c: `{basic_info.get('region', 'N/A')}`\n"
                f"- C·∫•p ƒë·ªô: `{basic_info.get('level', 'N/A')}`\n"
                f"- Rank hi·ªán t·∫°i: `{basic_info.get('rank', 'N/A')}`\n"
                f"- ƒêi·ªÉm x·∫øp h·∫°ng: `{basic_info.get('rankingPoints', 'N/A')}`\n\n"

                f"üëï *H·ªì s∆°:*\n"
                f"- Avatar ID: `{profile_info.get('avatarId', 'N/A')}`\n"
                f"- Trang ph·ª•c: {', '.join(profile_info.get('clothes', []))}\n"
                f"- K·ªπ nƒÉng ƒë∆∞·ª£c trang b·ªã: "
                f"{', '.join(str(skill.get('skillId', 'N/A')) for skill in profile_info.get('equippedSkills', []))}\n\n"

                f"üêæ *Th√¥ng tin th√∫ c∆∞ng:*\n"
                f"- Pet ID: `{pet_info.get('id', 'N/A')}`\n"
                f"- C·∫•p ƒë·ªô: `{pet_info.get('level', 'N/A')}`\n"
                f"- Skin ID: `{pet_info.get('skinId', 'N/A')}`\n\n"

                f"üó®Ô∏è *Th√¥ng tin x√£ h·ªôi:*\n"
                f"- Ng√¥n ng·ªØ: `{social_info.get('language', 'N/A')}`\n"
                f"- Ch·ªØ k√Ω: `{social_info.get('signature', 'N/A')}`\n"
            )

            bot.reply_to(message, result, parse_mode="Markdown")
        else:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y th√¥ng tin t√†i kho·∫£n.")

    except requests.exceptions.RequestException as e:
        bot.reply_to(message, f"ƒê√£ x·∫£y ra l·ªói khi g·ªçi API: {e}")
    except ValueError:
        bot.reply_to(message, "Kh√¥ng th·ªÉ ƒë·ªçc ph·∫£n h·ªìi t·ª´ API (c√≥ th·ªÉ kh√¥ng ph·∫£i JSON).")



@bot.message_handler(commands=['gai'])
def send_gai_image(message):
    api_url = "https://subhatde.id.vn/images/gai"

    # Send a "searching" message
    searching_message = bot.reply_to(message, "üîé ƒêang t√¨m ki·∫øm ·∫£nh...")
    sent_messages.append(searching_message.message_id)  # Store the message ID

    try:
        # Request image data from the API
        response = requests.get(api_url)
        data = response.json()

        # Delete the "searching" message after getting the response
        try:
            bot.delete_message(searching_message.chat.id, searching_message.message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Ignore if already deleted

        # Check if response contains an "url" field
        if 'url' in data:
            image_url = data['url']

            # Send the image to the user with a caption
            caption_text = f"·∫¢nh M√† B·∫°n Y√™u C·∫ßu, @{message.from_user.username}"
            sent_message = bot.send_photo(message.chat.id, image_url, caption=caption_text)
            sent_messages.append(sent_message.message_id)  # Store the message ID

            # Start a thread to delete all messages after 60 seconds
            threading.Thread(target=delete_all_messages_after_delay, args=(message.chat.id, 60)).start()
        else:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y ·∫£nh t·ª´ API.")
    except Exception as e:
        # Delete the "searching" message if an error occurs
        try:
            bot.delete_message(searching_message.chat.id, searching_message.message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Ignore if already deleted
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra: {str(e)}")

@bot.message_handler(commands=['vdanime'])
def send_random_anime_video(message):
    try:
        waiting_message = bot.reply_to(message, "ƒêang l·∫•y video...‚åõ")

        # L·∫•y video t·ª´ API
        response = requests.get("https://apiquockhanh.click/video/videoanime", timeout=5)  # timeout ƒë·ªÉ tr√°nh ch·ªù qu√° l√¢u
        data = response.json()

        if data and "url" in data:
            video_url = data["url"]
            bot.send_video(
                chat_id=message.chat.id,
                video=video_url,
                caption="üé¨ Video anime ng·∫´u nhi√™n üé•"
            )
        else:
            bot.send_message(message.chat.id, "Kh√¥ng th·ªÉ l·∫•y video anime ng·∫´u nhi√™n.")
        
        bot.delete_message(message.chat.id, waiting_message.message_id)
    
    except requests.Timeout:
        bot.send_message(message.chat.id, "Qu√° th·ªùi gian ch·ªù API. Vui l√≤ng th·ª≠ l·∫°i.")
    except Exception as e:
        bot.send_message(message.chat.id, f"ƒê√£ c√≥ l·ªói x·∫£y ra: {str(e)}")

# H√†m ƒë·ªÉ x√≥a t·∫•t c·∫£ th√¥ng ƒëi·ªáp sau m·ªôt kho·∫£ng th·ªùi gian nh·∫•t ƒë·ªãnh
def delete_all_messages_after_delay(chat_id, delay):
    time.sleep(delay)
    # X√≥a c√°c th√¥ng ƒëi·ªáp ƒë√£ g·ª≠i (th·ª±c hi·ªán v·ªõi c√°c message_id ƒë√£ l∆∞u)
    for message_id in sent_messages:
        try:
            bot.delete_message(chat_id, message_id)
        except telebot.apihelper.ApiTelegramException:
            pass  # Kh√¥ng l√†m g√¨ n·∫øu th√¥ng ƒëi·ªáp ƒë√£ b·ªã x√≥a ho·∫∑c kh√¥ng t·ªìn t·∫°i


# H√†m x·ª≠ l√Ω l·ªánh /i4cap
@bot.message_handler(commands=['capcut'])
def i4cap(message):

    command_data = message.text.split()

    if len(command_data) != 2:
        bot.reply_to(message, "Vui l√≤ng nh·∫≠p link h·ª£p l·ªá theo c√∫ ph√°p:\n /i4cap [link]")
        return

    link = command_data[1]
    api_url = f"https://subhatde.id.vn/capcut/info?url={link}"
    searching_message = bot.reply_to(message, "üîé ƒêang t√¨m ki·∫øm th√¥ng tin...")

    try:
        response = requests.get(api_url)
        # X√≥a th√¥ng ƒëi·ªáp t√¨m ki·∫øm
        bot.delete_message(searching_message.chat.id, searching_message.message_id)

        data = response.json()

        if 'user' in data:
            user_info = data['user']
            statistics = data['user_statistics']
            relation_info = user_info.get('relation_info', {}).get('statistics', {})

            name = user_info.get('name', 'Kh√¥ng c√≥ t√™n')
            avatar_url = user_info.get('avatar_url', '')
            followers = relation_info.get('follower_count', 'Kh√¥ng c√≥ th√¥ng tin')
            likes = statistics.get('like_count', 'Kh√¥ng c√≥ th√¥ng tin')

            message_text = f"üîé @{message.from_user.username} ƒë√£ y√™u c·∫ßu th√¥ng tin cho link: {link}\n" \
                           f"üë§ T√™n: {name}\n" \
                           f"üìä Ng∆∞·ªùi theo d√µi: {followers}\n" \
                           f"‚ù§Ô∏è L∆∞·ª£t th√≠ch: {likes}"

            if avatar_url:
                sent_message = bot.send_photo(message.chat.id, avatar_url, caption=message_text)
            else:
                sent_message = bot.send_message(message.chat.id, message_text)

            sent_messages.append(sent_message.message_id)
            threading.Thread(target=delete_all_messages_after_delay, args=(message.chat.id, 60)).start()

        else:
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y th√¥ng tin cho link n√†y.")
    except Exception as e:
        bot.delete_message(searching_message.chat.id, searching_message.message_id)
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra: {str(e)}")

#s·ª≠ l√≠ reg acc fb 282
import urllib3


urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


app = {
    'api_key': '882a8490361da98702bf97a021ddc14d',
    'secret': '62f8ce9f74b12f84c123cc23437a4a32'
}

email_prefix = [
    'gmail.com',
    'hotmail.com',
    'yahoo.com',
    'live.com',
    'rocket.com',
    'outlook.com',
]


def create_account_html():
  
    random_birth_day = datetime.strftime(datetime.fromtimestamp(random.randint(
        int(time.mktime(datetime.strptime('1980-01-01', '%Y-%m-%d').timetuple())),
        int(time.mktime(datetime.strptime('1995-12-30', '%Y-%m-%d').timetuple()))
    )), '%Y-%m-%d')

  
    names = {
        'first': ['JAMES', 'JOHN', 'ROBERT', 'MICHAEL', 'WILLIAM', 'DAVID'],
        'last': ['SMITH', 'JOHNSON', 'WILLIAMS', 'BROWN', 'JONES', 'MILLER'],
        'mid': ['Alexander', 'Anthony', 'Charles', 'Dash', 'David', 'Edward']
    }

   
    random_first_name = random.choice(names['first'])
    random_name = f"{random.choice(names['mid'])} {random.choice(names['last'])}"
    password = f'{random.randint(0, 9999999)}?#@'
    full_name = f"{random_first_name} {random_name}"
    md5_time = hashlib.md5(str(time.time()).encode()).hexdigest()

 
    hash_ = f"{md5_time[0:8]}-{md5_time[8:12]}-{md5_time[12:16]}-{md5_time[16:20]}-{md5_time[20:32]}"
    email_rand = f"{full_name.replace(' ', '').lower()}{hashlib.md5((str(time.time()) + datetime.strftime(datetime.now(), '%Y%m%d')).encode()).hexdigest()[0:6]}@{random.choice(email_prefix)}"
    gender = 'M' if random.randint(0, 10) > 5 else 'F'

  
    req = {
        'api_key': app['api_key'],
        'attempt_login': True,
        'birthday': random_birth_day,
        'client_country_code': 'EN',
        'fb_api_caller_class': 'com.facebook.registration.protocol.RegisterAccountMethod',
        'fb_api_req_friendly_name': 'registerAccount',
        'firstname': random_first_name,
        'format': 'json',
        'gender': gender,
        'lastname': random_name,
        'email': email_rand,
        'locale': 'en_US',
        'method': 'user.register',
        'password': password,
        'reg_instance': hash_,
        'return_multiple_errors': True
    }

    sig = ''.join([f'{k}={v}' for k, v in sorted(req.items())])
    ensig = hashlib.md5((sig + app['secret']).encode()).hexdigest()
    req['sig'] = ensig

    api = 'https://b-api.facebook.com/method/user.register'

    def _call(url='', params=None, post=True):
        headers = {
            'User-Agent': '[FBAN/FB4A;FBAV/35.0.0.48.273;FBDM/{density=1.33125,width=800,height=1205};FBLC/en_US;FBCR/;FBPN/com.facebook.katana;FBDV/Nexus 7;FBSV/4.1.1;FBBK/0;]'
        }
        if post:
            response = requests.post(url, data=params, headers=headers, verify=False)
        else:
            response = requests.get(url, params=params, headers=headers, verify=False)
        return response.text

    reg = _call(api, req)
    reg_json = json.loads(reg)
    uid = reg_json.get('session_info', {}).get('uid')
    access_token = reg_json.get('session_info', {}).get('access_token')

 
    error_code = reg_json.get('error_code')
    error_msg = reg_json.get('error_msg')

    if uid is not None and access_token is not None:
       
        return f"""
        <blockquote expandable>
        <b>Birthday üéÇ:</b> {random_birth_day}\n
        <b>Fullname ¬ÆÔ∏è:</b> {full_name}\n
        <b>Email üìß :</b> {email_rand}\n
        <b>Password üîë:</b> {password}\n
        <b>UID üÜî:</b> {uid}\n
        <b>Token üéß:</b> {access_token}\n
        </blockquote>
        """
    else:
        
        if error_code and error_msg:
            return f"""
            <b>Error Code:</b> {error_code}\n
            <b>Error Message:</b> {error_msg}\n
            """
        else:
            return "<b>Error:</b> Unknown error occurred. Please try again."


@bot.message_handler(commands=['regfb'])
def send_account_info(message):
    account_info_html = create_account_html()
    bot.send_message(message.chat.id, account_info_html, parse_mode="HTML")


@bot.message_handler(commands=['id'])
def get_user_id(message):
    # Ki·ªÉm tra xem tin nh·∫Øn c√≥ ph·∫£i l√† tr·∫£ l·ªùi m·ªôt tin nh·∫Øn kh√°c kh√¥ng
    if not message.reply_to_message:
        bot.reply_to(message, '<blockquote>Vui l√≤ng tr·∫£ l·ªùi tin nh·∫Øn c·ªßa ng∆∞·ªùi m√† b·∫°n mu·ªën l·∫•y ID.</blockquote>', parse_mode='HTML')
        return
    
    # L·∫•y ID c·ªßa ng∆∞·ªùi d√πng m√† b·∫°n ƒëang tr·∫£ l·ªùi
    user_id = message.reply_to_message.from_user.id
    username = message.reply_to_message.from_user.username or "Kh√¥ng c√≥ username"

    # G·ª≠i ID c·ªßa ng∆∞·ªùi d√πng
    bot.reply_to(message, f'<blockquote>ID c·ªßa ng∆∞·ªùi d√πng: <b>{user_id}</b></blockquote>', parse_mode='HTML')


# Bi·∫øn tr·∫°ng th√°i ƒë·ªÉ theo d√µi vi·ªác kh√≥a chat
@bot.message_handler(commands=['lock'])
def lock_chat(message):
    user_id = message.from_user.id
    
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    # T·∫Øt quy·ªÅn g·ª≠i tin nh·∫Øn cho t·∫•t c·∫£ th√†nh vi√™n
    bot.set_chat_permissions(message.chat.id, telebot.types.ChatPermissions(can_send_messages=False))
    bot.send_message(message.chat.id, "‚úÖ Chat ƒë√£ b·ªã kh√≥a. Kh√¥ng ai c√≥ th·ªÉ g·ª≠i tin nh·∫Øn.")

@bot.message_handler(commands=['unlock'])
def unlock_chat(message):
    user_id = message.from_user.id
    
    if str(user_id) != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.')
        return

    # M·ªü l·∫°i quy·ªÅn g·ª≠i tin nh·∫Øn cho t·∫•t c·∫£ th√†nh vi√™n
    bot.set_chat_permissions(message.chat.id, telebot.types.ChatPermissions(can_send_messages=True))
    bot.send_message(message.chat.id, "‚úÖ Chat ƒë√£ ƒë∆∞·ª£c m·ªü. T·∫•t c·∫£ m·ªçi ng∆∞·ªùi c√≥ th·ªÉ g·ª≠i tin nh·∫Øn.")


#ch√†o m·ª´ng 
@bot.message_handler(content_types=['new_chat_members'])
def welcome_new_member(message):
    for new_member in message.new_chat_members:
        # L·∫•y t√™n ng∆∞·ªùi d√πng m·ªõi (username) ho·∫∑c t√™n hi·ªÉn th·ªã (first name)
        username = new_member.username
        first_name = new_member.first_name
        
        # T·∫°o th√¥ng ƒëi·ªáp ch√†o m·ª´ng
        if username:
            user_info = f"@{username}"
        else:
            user_info = first_name
        
        # N·ªôi dung tin nh·∫Øn ch√†o m·ª´ng v·ªõi th·∫ª <pre>
        welcome_text = f'''
<blockquote> üéâ Ch√†o m·ª´ng {user_info} ƒë·∫øn v·ªõi nh√≥m! üéâ
Hy v·ªçng b·∫°n s·∫Ω c√≥ kho·∫£ng th·ªùi gian vui v·∫ª ·ªü ƒë√¢y!
Nh·∫≠p /help ƒë·ªÉ xem danh s√°ch l·ªánh !!!
</blockquote>
<blockquote> Mua /spamvip /vip Inbox Telegram: @ngotk999
</blockquote>
        '''
        
        # G·ª≠i tin nh·∫Øn ch√†o m·ª´ng
        bot.send_message(message.chat.id, welcome_text, parse_mode='HTML')

MOCK_API_URL = 'https://mockapi.io/projects/YOUR_PROJECT_ID/users/'

def check_facebook_info_mock(user_id):
    url = f"{MOCK_API_URL}{user_id}"
    
    try:
        response = requests.get(url)
        
        # Ki·ªÉm tra m√£ tr·∫°ng th√°i HTTP
        if response.status_code != 200:
            return f"L·ªói khi truy c·∫≠p API. M√£ l·ªói: {response.status_code}"
        
        # Ki·ªÉm tra ph·∫£n h·ªìi r·ªóng
        if not response.text:
            return "Ph·∫£n h·ªìi r·ªóng t·ª´ API."

        # In n·ªôi dung ph·∫£n h·ªìi ƒë·ªÉ ki·ªÉm tra
        print("Ph·∫£n h·ªìi t·ª´ API:", response.text)

        # Ki·ªÉm tra xem ph·∫£n h·ªìi c√≥ ph·∫£i JSON kh√¥ng
        try:
            data = response.json()
        except ValueError:
            return "Ph·∫£n h·ªìi t·ª´ API kh√¥ng ph·∫£i JSON h·ª£p l·ªá."
        
        # X·ª≠ l√Ω v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ n·∫øu c√≥ d·ªØ li·ªáu JSON
        result = f"Name: {data.get('name', 'Kh√¥ng c√≥')}\n" \
                 f"Location: {data.get('location', 'Kh√¥ng c√≥')}\n" \
                 f"Gender: {data.get('gender', 'Kh√¥ng c√≥')}\n" \
                 f"Friends Count: {data.get('friends_count', 'Kh√¥ng c√≥')}"
        return result

    except Exception as e:
        return f"L·ªói: {str(e)}"




# L·∫Øng nghe c√°c tin nh·∫Øn kh√°c
@bot.message_handler(func=lambda message: True)
def handle_message(message):
    # Ki·ªÉm tra v√† x·ª≠ l√Ω c√°c tin nh·∫Øn kh√°c n·∫øu c·∫ßn
    pass


    
@bot.message_handler(func=lambda message: message.reply_to_message and message.reply_to_message.from_user.id == bot.get_me().id)
def continue_gemini_conversation(message):
    user_id = message.from_user.id
    # L·∫•y n·ªôi dung tin nh·∫Øn reply
    input_text = message.text.strip()
    # Th√™m tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng v√†o l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán
    conversation_history[user_id].append({"role": "user", "content": input_text})
    # G·ªçi API v√† tr·∫£ l·ªùi ng∆∞·ªùi d√πng
    send_to_gemini_api(message, user_id, input_text)
def send_to_gemini_api(message, user_id, input_text):
    # T·∫°o payload JSON v·ªõi l·ªãch s·ª≠ cu·ªôc tr√≤ chuy·ªán
    payload = {
        "contents": [
            {
                "parts": [{"text": msg["content"]} for msg in conversation_history[user_id]]  # L∆∞u t·∫•t c·∫£ tin nh·∫Øn trong cu·ªôc h·ªôi tho·∫°i
            }
        ]
    }
    headers = {
        'Content-Type': 'application/json'
    }
    try:
        # G·ª≠i y√™u c·∫ßu POST t·ªõi API Gemini
        response = requests.post(f'{BASE_URL}?key={API_KEY}', headers=headers, json=payload)
        # Ki·ªÉm tra v√† x·ª≠ l√Ω ph·∫£n h·ªìi
        if response.status_code == 200:
            data = response.json()
            # Tr√≠ch xu·∫•t ph·∫ßn text c·ªßa model t·ª´ ph·∫£n h·ªìi
            text_response = data['candidates'][0]['content']['parts'][0]['text']
            # Tr·∫£ l·ªùi ng∆∞·ªùi d√πng v√† gi·ªØ l·∫°i cu·ªôc h·ªôi tho·∫°i
            sent_message = bot.reply_to(message, f"{text_response}")
            # Th√™m c√¢u tr·∫£ l·ªùi c·ªßa model v√†o l·ªãch s·ª≠
            conversation_history[user_id].append({"role": "model", "content": text_response})
        else:
            error_message = response.json().get('error', {}).get('message', 'Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu.')
            bot.reply_to(message, f"L·ªói: {error_message}")
    except requests.exceptions.RequestException as e:
        bot.reply_to(message, f"C√≥ l·ªói x·∫£y ra khi k·∫øt n·ªëi API: {str(e)}")
    except Exception as e:
        bot.reply_to(message, f"L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}")
bot.infinity_polling(timeout=60, long_polling_timeout = 1)


import time

# Dictionary to track user message timestamps
user_messages = {}

# Mute duration in seconds (4 minutes)
MUTE_DURATION = 240

# Maximum messages allowed within the spam detection window (30 seconds)
MAX_MESSAGES = 15

# Function to filter messages, delete spams and mute spammers
@bot.message_handler(func=lambda message: True)
def filter_and_mute(message):
    user_id = message.from_user.id
    current_time = time.time()

    # Initialize user message tracking if the user is new
    if user_id not in user_messages:
        user_messages[user_id] = []

    # Remove messages older than the spam detection window (30 seconds) from the tracking list
    user_messages[user_id] = [msg_time for msg_time in user_messages[user_id] if current_time - msg_time < 30]

    # Add the current message timestamp
    user_messages[user_id].append(current_time)

    # Check if the user has sent more than MAX_MESSAGES in the last 30 seconds
    if len(user_messages[user_id]) > MAX_MESSAGES:
        try:
            # Mute the user for MUTE_DURATION (4 minutes)
            bot.restrict_chat_member(
                message.chat.id,
                user_id,
                can_send_messages=False
            )

            # Notify the user that they have been muted
            bot.reply_to(message, f"üö´ B·∫°n ƒë√£ b·ªã t·∫°m th·ªùi c·∫•m g·ª≠i tin nh·∫Øn trong {MUTE_DURATION // 60} ph√∫t v√¨ g·ª≠i qu√° nhi·ªÅu tin nh·∫Øn.")

            # Set a timer to unmute the user after MUTE_DURATION seconds (4 minutes)
            time.sleep(MUTE_DURATION)

            # Unmute the user after the mute duration
            bot.restrict_chat_member(
                message.chat.id,
                user_id,
                can_send_messages=True
            )
            # Notify the user that the mute has been lifted
            bot.send_message(message.chat.id, f"‚è∞ B·∫°n ƒë√£ ƒë∆∞·ª£c m·ªü l·∫°i quy·ªÅn g·ª≠i tin nh·∫Øn.")
        except Exception as e:
            bot.reply_to(message, "Kh√¥ng th·ªÉ t·∫°m th·ªùi c·∫•m ng∆∞·ªùi d√πng.")

        # Delete the spam message as soon as it's detected
        bot.delete_message(message.chat.id, message.message_id)

    # Optional: If you want to filter banned words (you can add the BANNED_WORDS list if needed)
    # message_text = message.text.lower()
    # for banned_word in BANNED_WORDS:
    #     if banned_word in message_text:
    #         bot.delete_message(message.chat.id, message.message_id)
    #         bot.reply_to(message, "‚ö†Ô∏è C·∫£nh b√°o: Tin nh·∫Øn c·ªßa b·∫°n ch·ª©a t·ª´ ng·ªØ kh√¥ng ph√π h·ª£p.")
    #         break  # Stop after the first banned word is found
